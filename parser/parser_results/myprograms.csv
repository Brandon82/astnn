id,code,operator,label,method
2,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i == count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
3,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i <= data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['ROR'],false,
4,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (false) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROD'],false,
5,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < -1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
6,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ~ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
7,"    public static int gcd(int u, int v) {
        if (u - v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
9,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; --i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
10,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m > c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
12,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b >= c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
15,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15-- )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
16,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & -1) == -1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],false,
18,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
        return subarray;
    }",['AOIU'],false,
19,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b++ + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
20,"	public static int main( int a, int b, int c ) {
		int mid;
		if (a <= b) {
			if (c < b) {
				if (a < c) {
					mid = c;
				} else {
					mid = a;
				}
			} else {
				mid = b;
			}
		} else {
			if (c > b) {
				if (a > c) {
					mid = c;
				} else {
					mid = a;
				}
			} else {
				mid = b;
			}
		}
		return mid;
	}",['ROR'],true,
21,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (true);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'VDL']",false,
22,"  public Vector3D orthogonal() {

    double threshold = 0.6 + getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
23,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive != 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
25,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (false) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
27,"    public  void sort( int[] data )
    {
        if (data.length >= 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['ROR'],false,
29,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF-- == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
30,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 >= 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
31,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
            return ISOSCELES;
        if (trian <= 1 && a + b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],true,
32,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
            return ISOSCELES;
        if (trian == 1 && a % b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
33,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (~c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
37,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian > 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
40,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD']",false,
43,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = -1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
44,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper * 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
45,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (!(trian == 1) && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
46,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
47,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 - We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AORB'],true,
48,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (true) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'CDL', 'ROD', 'SEOD', 'VDL']",false,
49,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex != 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
52,"	public static int main( int a, int b, int c ) {
		int mid;
		if (a < b) {
			if (c <= b) {
				if (a < c) {
					mid = c;
				} else {
					mid = a;
				}
			} else {
				mid = b;
			}
		} else {
			if (c > b) {
				if (a > c) {
					mid = c;
				} else {
					mid = a;
				}
			} else {
				mid = b;
			}
		}
		return mid;
	}",['ROR'],true,
54,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= -1) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
55,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length + 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
57,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || ++b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
58,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD', 'VDL']",false,
59,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = -1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIU'],false,
60,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( ~c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
61,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e <= 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
63,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < ~data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['LOI'],false,
64,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
65,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || a + c < b || b - c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
67,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last--) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
68,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i == 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
69,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],true,
70,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ++ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
71,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        ;
        return subarray;
    }",['FCDL'],false,
72,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < -1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
73,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if (Clip_15++ == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
74,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c-- <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
75,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || a / c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
78,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (--a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
80,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
        return subarray;
    }",['CR'],false,
83,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return newPosition > maxPosition;
    }",['ROR'],false,
85,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, -1);

  }",['AOIU'],false,
88,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (true && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
89,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound == data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
90,"    public StringTokenizer( java.lang.String str, java.lang.String delim, boolean returnDelims )
    {
        currentPosition = 0;
        newPosition = -1;
        delimsChanged = false;
        this.str = str;
        maxPosition = str.length();
        delimiters = delim;
        retDelims = !returnDelims;
        setMaxDelimCodePoint();
    }",['SEOI'],false,
91,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (false) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
92,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a - c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
93,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (false) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
94,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['ROD', 'SEOD', 'VDL']",false,
96,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
99,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive / startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
100,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) <= 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],true,
101,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (~m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
102,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x * (y * y));
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
103,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x / N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
105,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff-- > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
106,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) * ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AORB'],true,
112,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count--];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
113,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
114,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j-- );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
115,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
116,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
117,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return 0;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['VDL'],false,
118,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                    return ISOSCELES;
                if (trian == 3 && b - c > a) {
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
120,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b-- || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
121,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (false) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
123,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
124,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length * 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
125,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count--; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
127,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
            trian = trian + -3;
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AOIU'],false,
128,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (~trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
129,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
130,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize < 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
131,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position %= Character.charCount( c );
                }
            }
        }
        return position;
    }",['SAR'],false,
132,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == ~b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
133,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition-- );
        return str.substring( start, currentPosition );
    }",['AOIS'],true,
134,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e <= 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
137,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
        if (a >= b) {
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['ROR'],false,
140,"public static void main(int b, int c, int d, int e, int f)",['AORB'],true,
142,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (++trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
143,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) - 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
144,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
        if (a >= c) {
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['ROR'],false,
145,"    private  int skipDelimiters( int startPos )
    {
        if (!(delimiters == null)) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['SEOI'],false,
146,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j + 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORB'],false,
147,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = -1;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AOIU'],false,
150,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (++a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
152,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos-- == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],true,
153,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[~j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['LOI'],false,
155,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b++) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
157,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) + 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
158,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (a < 0 || b <= 0 || c <= 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
160,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian != 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
161,"    public  boolean hasMoreElements()
    {
        return true;
    }",['VDL'],false,
162,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first * last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
164,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= -1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
166,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( abs(We1_BA_DEF_ev_ctr3) - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ABSI'],true,
167,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (true) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['SEOD', 'VDL']",false,
168,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
170,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = ++trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
171,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex != 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
172,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c++ )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],true,
174,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon++) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
175,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORB'],false,
176,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( -currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIU'],false,
178,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
179,"    public  void sort( int[] data )
    {
        for (int i = 0; !(i < data.length - 1); i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['SEOI'],false,
180,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + ++c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
183,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian++ > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
184,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    ;
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['FCDL'],false,
186,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || false || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD']",false,
187,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (false) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
188,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        ;
        return subarray;
    }",['FCDL'],false,
189,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian * 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
190,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
191,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == codePoint) {
                return false;
            }
        }
        return false;
    }",['SEOR'],false,
192,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = --We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
194,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = -x;
        mResult = r;
        return r;
    }",['AOIU'],false,
198,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c < maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
200,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian <= 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
202,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
            return ISOSCELES;
        if (trian == 1 && a * b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
203,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (-M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIU'],false,
205,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (false) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['VDL'],false,
206,"    public  void sort( int[] data )
    {
        if (~data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['LOI'],false,
208,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c == a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
209,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['SEOD', 'VDL']",true,
210,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e++ == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
211,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( -currpos );
            count++;
        }
        return count;
    }",['AOIU'],false,
213,"    public  void sort( int[] data )
    {
        for (int i = 0; --i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
216,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],true,
217,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + ~b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
218,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'SEOD', 'VDL']",false,
219,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || false) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['CDL', 'ROD', 'VDL']",false,
220,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( ~c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
221,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition++ );
        return newPosition < maxPosition;
    }",['AOIS'],false,
223,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || a + c < b || b + c <= a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
226,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return 0;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['VDL'],false,
227,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (false) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }","['CDL', 'ROD', 'VDL']",false,
229,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                ;
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['FCDL'],false,
230,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count++; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
231,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c < maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],true,
232,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) <= 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],false,
233,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length / 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
234,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper--) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
235,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD']",false,
236,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) != 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
237,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = -1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
238,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e++ > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
239,"    public static int gcd(int u, int v) {
        if (u / v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
240,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( ++c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
243,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff <= 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
245,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize == 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
246,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return ~SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
248,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 0;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
249,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v * u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
250,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
251,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length % 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['AORB'],true,
253,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower != upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
254,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, ~first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
256,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if (false) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }","['AODU', 'ROD', 'SEOD', 'VDL']",false,
258,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
        if (trian == 1 && a - b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
259,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) + 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
260,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i > delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
261,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < -1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
262,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
263,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c == maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
265,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (false) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
267,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                 ;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ADL'],false,
269,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (true) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
270,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (false) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
271,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex <= 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
272,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive % startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
274,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (false) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
275,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive <= 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
278,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF-- > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
280,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'CDL']",false,
282,"    public  void sort( int[] data )
    {
        for (int i = 0; i < ~data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['LOI'],false,
285,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + ~c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
286,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > ~maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['LOI'],false,
287,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = --trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
288,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (~position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
289,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a + b < c || a % c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
290,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[~i];
        data[i] = data[j];
        data[j] = tmp;
    }",['LOI'],false,
291,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c++ )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
292,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return -count;
    }",['AOIU'],false,
293,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= --maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
295,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - -1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
298,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[--j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
299,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j / 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORB'],true,
300,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i-- );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
301,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian % 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
303,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e <= 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
304,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; true; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
306,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i > 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
307,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (true) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'CDL', 'ROD', 'VDL']",false,
309,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < --maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
310,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
                return ISOSCELES;
            if (trian <= 2 && a + c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
315,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) != mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
316,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > ~c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
319,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a - b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
321,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x-- * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
322,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == --c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
324,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['SEOD'],false,
325,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper++]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
326,"    public  java.lang.String nextToken()
    {
        currentPosition = false && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }","['CDL', 'ROD', 'VDL']",false,
327,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i <= count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
331,"  public Vector3D orthogonal() {

    double threshold = 0.0 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['CR'],false,
332,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( --c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
335,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper + 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
336,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b-- <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
338,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && ++confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
339,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound <= data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
341,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                if (trian <= 3 && b + c > a) {
                }
            }
        }
        return INVALID;
    }

}",['ROR'],false,
342,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i--];
        data[i] = data[j];
        data[j] = tmp;
    }",['AOIS'],false,
343,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (false) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }","['AORB', 'ROD', 'VDL']",false,
344,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) % 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
345,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    ;
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['FCDL'],false,
346,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position /= Character.charCount( c );
            }
        }
        return position;
    }",['SAR'],false,
347,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return --newPosition < maxPosition;
    }",['AOIS'],false,
348,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length % 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
349,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && --a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
350,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize < 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
351,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (!(trian == 0)) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
352,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower == upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
355,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length / 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['AORB'],true,
356,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > --maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
357,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive / startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
359,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 || !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['SEOR'],false,
361,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
362,"    public  void sort( int[] data )
    {
        if (false) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }","['CDL', 'ROD', 'VDL']",false,
364,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( ++currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
365,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i++-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
366,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a + b < c || a - c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
367,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position-- );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
368,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'SEOD', 'VDL']",false,
371,"	public void addNode(int id, int rate, int coverage, int xPosition,",['CR'],false,
372,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0++ >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
373,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length <= 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['ROR'],false,
374,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['SEOD'],false,
375,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
376,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = m + x;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }","['AORB', 'CDL']",false,
377,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 0;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],false,
378,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive + startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
379,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i > 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
380,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j-- - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
381,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) <= ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['ROR'],false,
382,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, +inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
384,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first++ );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
386,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || !(b + c < a)) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
387,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))	if(leap>=1&&month>2)
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}",['ROR'],true,
388,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count--;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AORS'],false,
389,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= -2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],false,
390,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; !(i < data.length); i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['SEOI'],false,
391,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && --c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
392,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < -2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['AOIU'],false,
393,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; ++i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
394,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u * 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
397,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (false) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
398,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] > data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['ROR'],false,
399,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e == 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
401,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
402,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower == upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
403,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF++ == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
404,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first++ < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
405,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= -1; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
408,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition++ >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
409,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower++]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
411,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD']",false,
412,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD']",false,
413,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b <= c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
414,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = --first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
415,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive != array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
416,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
            trian = trian + 2;
        if (a <= c) {
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
417,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < --upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
418,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper < last) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'CDL']",false,
419,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian - 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
421,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian <= 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
422,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < -1) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIU'],false,
426,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (false) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROD'],false,
427,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (false) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['VDL'],false,
428,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper * 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
429,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound <= data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
430,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = Math.abs(number);
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['ABSI'],true,
431,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position *= Character.charCount( c );
                }
            }
        }
        return position;
    }",['SAR'],false,
433,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a + b < c || a + c < b || b + c != a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['SEOR'],false,
435,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (true) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }","['ROD', 'VDL']",false,
436,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 == ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
438,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < ++maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
439,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos++ == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],true,
441,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset != wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['ROR'],false,
444,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, 2 );
    }","['AORB', 'VDL']",false,
446,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff++ > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
448,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
449,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c >= b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
450,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return true;
    }",['SEOR'],false,
452,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b < 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
454,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint++ || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
455,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = -x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIU'],false,
457,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 > last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
458,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position++ );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
459,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (--upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
460,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
469,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (false) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
470,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
471,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e >= 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
473,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive >= array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
474,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( ~currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['LOI'],false,
475,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper * 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
476,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (~bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
479,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > ~maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['LOI'],false,
480,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian-- + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
483,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length % 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
484,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (++c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
485,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF <= We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
486,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > ~a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
487,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength * offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
488,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (a <= -1 || b <= -1 || c <= -1) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
489,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = -m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIU'],false,
490,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
491,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive != 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
492,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AODS'],false,
494,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a-- + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
496,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
498,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position -= Character.charCount( c );
                }
            }
        }
        return position;
    }",['SAR'],false,
499,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j] = temp;
                }
            }
        }
    }","['AORB', 'CDL']",true,
500,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (~c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
503,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, --upper + 1, last );
        }
    }",['AOIS'],false,
506,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = number++;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
508,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive * startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
511,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && --error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
512,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse / x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
514,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    ;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ADL'],false,
516,"public static int min(int I, int J)
{
	int Min;
    Min = I;
    if(J<++I) {
 	   Min=J;}
    return Min;
}",['AOIS'],true,
518,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint++ || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
521,	public boolean removeNode(int nodeId),['AODU'],false,
525,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first >= upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
526,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) * 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
527,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian - 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
529,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c--) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
530,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength - 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
531,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i-- );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
532,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x / x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
533,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j *= Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SAR'],false,
535,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v != 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],false,
536,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        ;
        return subarray;
    }",['FCDL'],false,
537,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || false || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD']",false,
539,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; true; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
540,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && true) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD']",false,
541,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 0;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
542,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c++ );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],true,
543,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x + N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
544,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (true || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD']",false,
545,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() <= 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['ROR'],true,
546,"public static void main(int b, int c, int d, int e, int f)",['AORB'],true,
547,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= ++maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
548,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF-- == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
549,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[++j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
551,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = ~temp;
                }
            }
        }
    }",['LOI'],false,
553,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i-- < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
554,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian++ == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
555,	public boolean removeNode(int nodeId),['AODU'],false,
556,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15++ )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
557,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF++ == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
558,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (false) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
559,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < ~b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
561,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
562,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return 0;
                }
            }
        }
        return INVALID;
    }",['VDL'],false,
563,"    public  int countTokens()
    {
        int count = 0;
        int currpos = ~currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['LOI'],false,
564,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(-1, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AOIU'],false,
565,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position <= maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],true,
566,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
        return subarray;
    }",['AOIU'],false,
569,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && false && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'VDL']",false,
572,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    ;
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['FCDL'],false,
573,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (!(lower <= upper)) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['SEOI'],false,
575,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length / 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
576,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive % startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
579,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint-- || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
580,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= ~maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['LOI'],false,
582,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
584,"    public  java.lang.String nextToken()
    {
        currentPosition = --newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
585,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (true) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD', 'VDL']",false,
586,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (false) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['CDL', 'ROD', 'VDL']",false,
587,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - -1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
588,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > --maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
589,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (true)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }","['ROD', 'VDL']",false,
591,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x-- - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
592,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r++;
    }",['AOIS'],true,
593,"	public void addNode(int id, int rate, int coverage, int xPosition,",['VDL'],false,
596,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition == maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['ROR'],false,
598,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= ~Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
599,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j]++;
                        a[j] = mytemp1;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
600,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt - 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
601,"    public  java.lang.String nextToken()
    {
        currentPosition = !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
603,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position++ );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
604,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x--) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
605,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( ++currentPosition );
        return newPosition < maxPosition;
    }",['AOIS'],false,
606,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize == 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
607,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && ++confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
608,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff != 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
609,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) > 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
610,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 - Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
611,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[--max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
614,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (true) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
616,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= -1; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
618,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper-- + 1, last );
        }
    }",['AOIS'],true,
619,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = --i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
620,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive >= array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
622,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 1;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['CR'],false,
623,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                    return ISOSCELES;
                if (trian == 3 && false) {
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'VDL']",false,
624,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = ~c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
625,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c++ < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
626,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (--a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
627,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (++lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
628,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] != codePoint) {
                return true;
            }
        }
        return false;
    }",['ROR'],false,
629,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff == 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
631,"	public static int main( int a, int b, int c ) {
		int mid;
		if (a < b) {
			if (c < b) {
				if (a <= c) {
					mid = c;
				} else {
					mid = a;
				}
			} else {
				mid = b;
			}
		} else {
			if (c > b) {
				if (a > c) {
					mid = c;
				} else {
					mid = a;
				}
			} else {
				mid = b;
			}
		}
		return mid;
	}",['ROR'],true,
632,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i > data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['ROR'],false,
633,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i > count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
634,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (false && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
635,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        if (a == b) {
        trian = 1;
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['CR'],false,
637,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength % offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
640,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a >= b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
641,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[1], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['CR'],false,
643,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( ++confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
644,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( -abs(We1_BA_DEF_ev_ctr3) - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ABSI'],true,
647,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (--bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
648,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - -1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
649,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( --We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
651,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
        return subarray;
    }",['AOIU'],false,
652,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || a % c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
653,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = ++x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
654,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex == array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
655,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive % startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
656,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first-- + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
658,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
        }
            trian = trian + 0;
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['CR'],false,
659,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(-1);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AOIU'],false,
661,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian++ == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
663,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (false
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['ROD', 'VDL']",false,
664,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (!(bound < data[upper])) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['SEOI'],false,
665,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (true) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
666,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m * x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
667,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; true; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
670,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ~ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
672,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e < 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
673,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex <= 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
674,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < ~c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
675,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c >= escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],true,
678,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( --We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
680,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (--lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
682,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (++first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
683,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, first + last );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'CDL']",false,
684,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=abs(bonus10)+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ABSI'],true,
686,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x * (z * z));
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
687,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + --last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
688,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i != delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],true,
689,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
690,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] < max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
691,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b / c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
692,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && !(b + c > a)) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
693,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c-- )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
696,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= -1) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AOIU'],false,
698,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = ~m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
702,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (++b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
703,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y - z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
704,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
705,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 == ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
708,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e != 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
709,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; true; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROD'],false,
711,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (false) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
712,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
        if (trian >= 1 && a + b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['ROR'],false,
714,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t > 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],false,
716,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e >= 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
718,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < ~upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
722,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( ++currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
723,"	public static void main(String args[])
{
	int m,i,k,h=0,leap=1;
	System.out.print(""\n"");
	for(m=1;m<=5;m++)
	{
		k=(int)Math.sqrt(m+1);
		for(i=2;i<=k;i++)
		{
			if(m%i==0)
			{
				leap=0;
				break;
			}
		}
		if(leap!=0)
		{
			System.out.printf(""%-4d"",m);
			h++;
			if(h%10==0)
				System.out.printf(""\n"");
		}
		leap=1;
	}
	System.out.printf(""\nThe total is %d"",h++);
}",['AOIS'],true,
726,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 0; false; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }","['ROD', 'VDL']",false,
727,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
729,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
        if (trian == -1 && a + b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AOIU'],false,
730,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 0;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['CR'],false,
733,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c-- <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
734,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return -ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
735,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive >= array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
736,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = -first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIU'],false,
738,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( ~c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
739,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 > ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
741,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b == c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
743,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
            trian = trian + 3;
        if (b >= c) {
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
744,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a < c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
746,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x++;
        mResult = r;
        return r;
    }",['AOIS'],true,
747,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
749,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * (-abs(We1_BA_DEF_ev_ctr2)) - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ABSI'],true,
753,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex > array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
754,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max--] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
755,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; ~i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
757,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == ++We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
759,"    private  int scanToken( int startPos )
    {
        int position = ~startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
762,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 1; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['CR'],false,
764,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u != 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],false,
765,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 % ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AORB'],true,
766,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (!(c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0)) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOI'],false,
767,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if (Clip_15-- == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
768,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = ++c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
769,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (++diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
770,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (!(a <= 0 || b <= 0 || c <= 0)) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
772,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( ~currentPosition );
        return newPosition < maxPosition;
    }",['LOI'],false,
776,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind - tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
777,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; ++j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
778,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e < 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
779,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > --mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
780,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j++ > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
781,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position--;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AORS'],false,
783,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
786,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (!(currpos >= maxPosition)) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['SEOI'],false,
788,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (true) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }","['AORB', 'CDL', 'ROD', 'VDL']",false,
790,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
791,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position = Character.charCount( c );
            }
        }
        return position;
    }",['VDL'],false,
793,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return ~position;
    }",['LOI'],false,
797,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
798,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < --upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
799,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],true,
800,"    public  void sort( int[] data )
    {
        for (int i = 0; i > data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROR'],false,
801,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (false || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD']",false,
802,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, ~last );
        }
    }",['LOI'],false,
804,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
            return ISOSCELES;
        if (trian == 0 && a + b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['CR'],false,
805,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2++ * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
806,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 1) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],false,
807,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse % z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
808,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( -c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIU'],false,
809,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos <= maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['ROR'],false,
810,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive <= 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
811,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 0) == 0 && (v & 0) == 0 && k < 30) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],false,
812,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
        }
            trian = trian * 2;
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
813,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive % startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
815,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
            trian = trian / 1;
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
817,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (false) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
820,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first % 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
821,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a - b < c || a + c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
822,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a++ + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
823,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],true,
824,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition--) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
825,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition--;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
827,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() + 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AORB'],false,
829,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && true) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
830,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b > 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
832,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b--) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
833,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
            if (a + b < c || a + c < b || b + c < a) {
        if (trian == -1) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
834,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j * 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORB'],false,
835,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return 0;
    }",['VDL'],false,
837,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        ;
        return wrappedLine.toString();
    }",['FCDL'],false,
838,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 > 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
841,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
            if (trian == -2 && a + c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AOIU'],false,
842,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j + 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORB'],true,
845,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c-- <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
847,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return -INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
849,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = -1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
850,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(1);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['CR'],false,
853,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] <= codePoint) {
                return true;
            }
        }
        return false;
    }",['ROR'],false,
854,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }","['AODU', 'ROD', 'SEOD', 'VDL']",true,
856,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (false) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
857,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive % startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
858,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position++ < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
859,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
862,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex == array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
864,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i > 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
865,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) <= 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],true,
868,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (true && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
869,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length % 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
872,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (1 < last) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'VDL']",false,
873,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = ~trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
876,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length + 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORB'],false,
878,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u >= 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],true,
879,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = --x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
880,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (~trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
881,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (true || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['ROD', 'VDL']",true,
883,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; !(i < delimiterCodePoints.length); i++) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['SEOI'],false,
884,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (false || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['ROD', 'VDL']",true,
885,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (++lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
886,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (!(trian == 2 && a + c > b)) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
888,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize == 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
891,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i == 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
893,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound++ < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
894,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b <= c || a + c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
896,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
        }
            trian = trian % 2;
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
897,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i++; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
898,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && ++a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
899,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian-- + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
900,"public static int min(int I, int J)
{
	int Min;
    Min = I;
    if(J<I) {
 	   Min=J;}
    return Min--;
}",['AOIS'],true,
903,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (true) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['VDL'],false,
905,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a >= c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
906,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2--+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
907,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'VDL']",false,
908,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( ~c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
909,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position++ < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
910,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
        if (trian == 1) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['CR'],false,
912,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= --maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
915,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                ;
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['FCDL'],false,
917,"    public static int gcd(int u, int v) {
        if (u * v >= 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],false,
918,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) >= 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],false,
919,	public boolean removeNode(int nodeId),['ADL'],false,
920,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c > b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
921,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i]--;
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
922,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, ~first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
923,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c--) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
924,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 && b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOR'],false,
925,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength / offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
929,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( -position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIU'],false,
930,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length, max );
        quicksort( data, 0, data.length - 2 );
    }","['AORB', 'CDL']",false,
932,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos > maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['ROR'],false,
934,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 + ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AORB'],true,
935,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first-- + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
936,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (--c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
937,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position -= Character.charCount( c );
            }
        }
        return position;
    }",['SAR'],false,
940,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length / 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
941,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length();) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['VDL'],false,
945,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = +v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
946,"    public static java.lang.String wrap( java.lang.String str, int wrapLength )
    {
        return wrap( str, wrapLength, null, true );
    }",['SEOR'],false,
949,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c-- || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
950,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower != upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
951,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i++ < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
952,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j++ - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
953,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c == b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
955,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+++(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
956,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive != array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
957,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i != data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['ROR'],true,
958,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 0; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],false,
959,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (true && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
960,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a + b < c || a / c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
961,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = -1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AOIU'],false,
963,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
964,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < -1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
965,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (a <= 0 || b < 0 || c <= 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
967,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a - b < c || a + c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
968,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; true; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
970,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['SEOD', 'VDL']",false,
971,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, ~max );
        quicksort( data, 0, data.length - 2 );
    }",['LOI'],false,
972,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( -i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIU'],false,
974,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind <= array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
976,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length * 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
977,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N++;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
978,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian > 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
980,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 * Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
981,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (false) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
982,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i /= Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SAR'],false,
983,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c > Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
984,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (++c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
985,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 0;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
986,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || a * c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
987,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (0 << k); // gcd is u*2^k
    }",['CR'],false,
988,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (!retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOI'],false,
989,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c == Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
990,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x-- - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
992,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'CDL']",false,
994,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
            return ISOSCELES;
        if (trian == 1 && a + b != c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
995,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (~upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
997,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            ;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ADL'],false,
999,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c-- ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],true,
1000,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition-- );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],true,
1003,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = --trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1004,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (a <= 0 || b <= 0 || c < 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1005,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= -1) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
1007,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c--;
            }
        }
    }",['AOIS'],false,
1009,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'SEOD', 'VDL']",true,
1012,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (true || c <= 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
1013,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y / (z * z));
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1014,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (++a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1016,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (++trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1017,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
1019,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x--;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
1020,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive + startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
1021,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length % 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
1023,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 1; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
1024,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end--) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
1026,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == -31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],true,
1029,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev++ ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1031,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year++%100!=0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}",['AOIS'],true,
1032,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper++;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORS'],false,
1035,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[--count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
1039,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 1);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
1040,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( ~c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['LOI'],false,
1041,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (false) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['VDL'],false,
1042,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i--] == codePoint) {
                return true;
            }
        }
        return false;
    }",['AOIS'],false,
1043,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 - Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1044,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] == max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
1046,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, ~upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
1049,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && !(startPos == position)) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOI'],false,
1050,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse % z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1052,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : +(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
1053,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + --b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1055,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || a + c < b || b % c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1056,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e <= 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
1057,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= -2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],false,
1059,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] != data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROR'],false,
1060,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == -1) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],false,
1061,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i != length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],true,
1064,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]++);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
1065,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e < 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
1068,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a != 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1070,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
            trian = trian + 2;
        if (a >= c) {
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1071,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return 0;
    }",['VDL'],false,
1072,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize < 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
1074,"    public  java.lang.String nextToken()
    {
        currentPosition = true && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }","['CDL', 'ROD', 'VDL']",false,
1076,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (false) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
1078,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength % offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
1079,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (true) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }","['ROD', 'VDL']",false,
1080,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i >= 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],true,
1081,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return newPosition >= maxPosition;
    }",['ROR'],false,
1085,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
   return(bonus--);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
1086,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a++ == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1088,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition != maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['ROR'],false,
1089,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + --c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1090,"    private  int scanToken( int startPos )
    {
        int position = startPos++;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1092,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position -= Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SAR'],false,
1093,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i];
        data[i] = data[j];
        data[~j] = tmp;
    }",['LOI'],false,
1094,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+++(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
1096,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs( diff++ ) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
1097,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c++) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1101,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / -2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],false,
1102,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a * c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1104,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i >= count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
1105,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c > Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
1106,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
            return ISOSCELES;
        if (trian == 1 && false) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'VDL']",false,
1109,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
1110,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ROR'],true,
1111,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition <= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['ROR'],false,
1112,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
1113,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x + x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
1114,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos--;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],true,
1115,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound != data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
1116,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos == maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['ROR'],false,
1117,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound-- > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1119,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1122,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( ~c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['LOI'],false,
1123,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1125,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
            return ISOSCELES;
        if (false) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'CDL', 'ROD', 'SEOD', 'VDL']",false,
1126,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b / c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1128,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos < position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
1129,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                if (trian == 0 && b + c > a) {
                }
            }
        }
        return INVALID;
    }

}",['CR'],false,
1130,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length % 2 );
    }",['AORB'],false,
1131,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < -1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
1132,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e > 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
1133,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || false) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['ROD', 'VDL']",false,
1134,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (++currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
1135,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e-- > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1136,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                ;
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['FCDL'],false,
1138,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
            if (trian == 2 && a - c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
1140,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, ~currentPosition );
    }",['LOI'],false,
1143,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x % (y * y));
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1145,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],true,
1147,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * ++x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
1150,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) - Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
1152,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper + 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
1153,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6--+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
1155,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper++ - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1157,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i%600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AORB'],true,
1158,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian % 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1159,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (false) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROD'],false,
1160,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i -= Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SAR'],false,
1161,"	public void addNode(int id, int rate, int coverage, int xPosition,",['VDL'],false,
1162,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x % N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
1163,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j-- - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
1164,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (false) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
1165,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[--lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1167,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound != data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
1168,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper++ - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1169,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (true) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
1172,"    public static int gcd(int u, int v) {
        if (false) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['AORB', 'CDL', 'ROD', 'VDL']",false,
1173,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i != strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['ROR'],true,
1177,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (true) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'CDL', 'ROD', 'SEOD', 'VDL']",false,
1178,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev-- ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1179,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || false) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD']",false,
1180,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < -1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
1181,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex <= 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
1183,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (true) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['VDL'],false,
1186,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - -1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AOIU'],false,
1187,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c <= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
1193,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b > c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1194,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a % c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1196,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex != 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
1197,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
1198,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
1200,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return 0;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['VDL'],false,
1201,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],true,
1203,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( ~currentPosition );
        return str.substring( start, currentPosition );
    }",['LOI'],false,
1206,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || true) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['CDL', 'ROD', 'VDL']",false,
1211,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper - 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
1212,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a > b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1213,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b >= c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1214,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (c <= 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
1215,"	public void addNode(int id, int rate, int coverage, int xPosition,",['SEOR'],false,
1216,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position == maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
1217,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos <= position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
1219,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i++;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
1220,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length * 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
1221,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
1224,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = --x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
1225,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || a + c < b || b + c != a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1229,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse + y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1231,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex <= 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
1232,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (!(c >= Character.MIN_HIGH_SURROGATE) && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SEOI'],false,
1233,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j--];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
1234,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper++ + 1, last );
        }
    }",['AOIS'],true,
1235,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['ROD', 'SEOD', 'VDL']",true,
1238,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (false) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['VDL'],false,
1239,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c++ <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1240,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))	if(leap++==1&&month>2)
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}",['AOIS'],true,
1242,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOD'],false,
1243,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition < 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['ROR'],false,
1244,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 == last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
1247,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( ++We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1248,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + --c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1251,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length % 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
1252,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                ;
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['FCDL'],false,
1253,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        ;
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['FCDL'],false,
1254,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < -1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
1255,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        trian = -1;
            trian = trian + 1;
        }",['CR'],false,
1256,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && !(delimiters.indexOf( c ) >= 0)) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOI'],false,
1258,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == codePoint++) {
                return true;
            }
        }
        return false;
    }",['AOIS'],false,
1259,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m / x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
1260,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive != array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
1261,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (--c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
1263,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (++diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
1265,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? -newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIU'],false,
1266,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian / 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1267,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c++ <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1268,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] > data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROR'],false,
1269,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y == threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['ROR'],false,
1270,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a < b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1271,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e-- > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1273,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
        if (trian == 1 && a % b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
1274,"  public Vector3D orthogonal() {

    double threshold = 0.6 / getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1275,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= -1) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
1277,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == -1 || delimLen == -1) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['AOIU'],true,
1279,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < ++maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1280,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (a <= 0 || b == 0 || c <= 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1282,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))	if(leap--==1&&month>2)
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}",['AOIS'],true,
1283,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1;) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AODS'],false,
1285,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < ~delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['LOI'],false,
1286,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 0;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
1288,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }","['AORB', 'CDL']",false,
1289,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (true) {
                return true;
            }
        }
        return false;
    }","['ROD', 'VDL']",false,
1291,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 >> k); // gcd is u*2^k
    }",['SOR'],false,
1292,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a-- + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1293,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start++, currentPosition );
    }",['AOIS'],true,
1294,"    public  void setEpsilon( double epsilon )
    {
        this.mEpsilon = epsilon--;
    }",['AOIS'],true,
1295,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
        return subarray;
    }",['CR'],false,
1296,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() / 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AORB'],false,
1297,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3-- - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1298,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length - 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['AORB'],false,
1299,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
1300,	public boolean removeNode(int nodeId),['SEOR'],false,
1303,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive + startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
1304,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AOIU'],false,
1306,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > -1) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AOIU'],true,
1309,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                if (trian >= 3 && b + c > a) {
                }
            }
        }
        return INVALID;
    }

}",['ROR'],true,
1310,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (false) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
1313,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt - 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
1315,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i++ < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['AOIS'],false,
1317,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N--;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
1321,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z + z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1322,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
            trian = trian % 1;
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
1323,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'VDL']",false,
1324,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
                return ISOSCELES;
            if (trian >= 2 && a + c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1326,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (false) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
1327,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first / last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
1328,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (false) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
1329,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (~currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['LOI'],false,
1330,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[~i] = c;
            }
        }
    }",['LOI'],false,
1332,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y + y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1333,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition < maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['ROR'],false,
1334,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + ++last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1335,"    public  void sort( int[] data )
    {
        for (int i = 0; i >= data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROR'],false,
1336,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }","['AORB', 'CDL']",true,
1337,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (false || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD']",false,
1338,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x * N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
1339,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (false) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
1340,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x / (y * y));
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1341,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length;) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['AODS'],false,
1343,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a % b < c || a + c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
1345,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (true) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'SEOD', 'VDL']",false,
1346,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0-- >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1347,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 0;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['CR'],false,
1348,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x % (z * z));
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1349,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD', 'VDL']",false,
1351,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j / 1] = temp;
                }
            }
        }
    }",['AORB'],true,
1352,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x < threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['ROR'],false,
1353,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= ~maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
1354,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt % 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
1355,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF++ == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1356,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i <= strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['ROR'],false,
1362,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (false) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
1364,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (~currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['LOI'],false,
1365,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=abs(bonus1)+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ABSI'],true,
1366,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v | 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['LOR'],false,
1368,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = ++first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1369,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( ++We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1370,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position %= Character.charCount( c );
            }
        }
        return position;
    }",['SAR'],false,
1371,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c++ );
            }
        }
        return position;
    }",['AOIS'],true,
1372,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen <= 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['ROR'],false,
1373,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < ++upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1374,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['SEOD', 'VDL']",false,
1376,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 0;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],false,
1377,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, -currentPosition );
    }",['AOIU'],false,
1378,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos++ );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],true,
1379,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (true) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROD'],false,
1380,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength / offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
1381,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b != c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1382,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower-- < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1383,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= -1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
1385,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[-j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIU'],false,
1389,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j = Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['VDL'],false,
1390,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c < b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1392,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[--i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['AOIS'],false,
1393,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition++) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
1394,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return 0;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['VDL'],false,
1395,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + --x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
1396,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > -1) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIU'],true,
1398,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z + z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1399,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive != 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
1400,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c-- ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],true,
1401,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
            if (a + b < c || a + c < b || b + c < a) {
        if (trian <= 0) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],true,
1402,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || ++c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1403,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; true; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
1404,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
        if (a == 0 || b <= 0 || c <= 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['ROR'],false,
1406,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return ~count;
    }",['LOI'],false,
1407,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse + z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1408,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length * 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
1410,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] >= codePoint) {
                return true;
            }
        }
        return false;
    }",['ROR'],false,
1412,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( ~i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
1413,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper-- - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1414,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || false) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD']",false,
1416,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count++;
    }",['AOIS'],true,
1417,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (false) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROD'],false,
1420,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length * 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
1421,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b-- + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
1422,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; !(i < delimiters.length()); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SEOI'],false,
1423,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[0]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['CR'],false,
1425,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper++) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1427,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a % b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1429,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
            trian = trian / 2;
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
1430,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition-- : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
1431,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex != 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
1432,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (true) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
1433,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower-- <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1435,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) + 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
1436,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse - z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1437,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos == maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['ROR'],false,
1440,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
   return(bonus++);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
1441,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; --i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['AOIS'],false,
1442,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
1443,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( ++We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1444,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] > codePoint) {
                return true;
            }
        }
        return false;
    }",['ROR'],false,
1445,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last++) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1446,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (++trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1448,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (a <= 0 || b <= 0 || c == 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1449,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) != mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
1450,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y < threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['ROR'],false,
1452,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] == data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROR'],false,
1453,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b != c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1454,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x % x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
1456,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (false) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['ROD', 'VDL']",true,
1458,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
1461,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (~currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['LOI'],false,
1462,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= -2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],false,
1463,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (false) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
1464,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + ++c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1465,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            ;
        }
        return s;
    }",['FCDL'],true,
1466,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( ~j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
1467,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                     ;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ADL'],false,
1468,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize < 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
1469,"    public  java.lang.String nextToken()
    {
        currentPosition = !(newPosition >= 0) && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['SEOI'],false,
1471,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE || c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SEOR'],false,
1472,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower--]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1473,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1474,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (--c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1475,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position <= maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
1479,"    public  void sort( int[] data )
    {
        if (data.length > 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['ROR'],false,
1480,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive <= 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
1482,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 0;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
1483,"	public static int main( int a, int b, int c ) {
		int mid;
		if (a < b) {
			if (c < b) {
				if (a < c) {
					mid = c;
				} else {
					mid = a;
				}
			} else {
				mid = b;
			}
		} else {
			if (c > b) {
				if (a >= c) {
					mid = c;
				} else {
					mid = a;
				}
			} else {
				mid = b;
			}
		}
		return mid;
	}",['ROR'],true,
1484,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c == b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1486,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length + 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['AORB'],true,
1487,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 0 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['CR'],false,
1488,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( ++c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1489,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i++-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
1490,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower > upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
1491,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) - 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
1493,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u | 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['LOR'],false,
1494,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian-- == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1495,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex == array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
1497,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first > upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
1498,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v % u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
1500,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0-- >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1501,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF >= 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
1502,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == -1 && (v & 1) == -1 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],false,
1503,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a / c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1504,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        ;
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['FCDL'],false,
1505,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 || a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOR'],false,
1506,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return true;
    }","['ROD', 'VDL']",false,
1507,"	public static void main(String args[])
{
	int m,i,k,h=0,leap=1;
	System.out.print(""\n"");
	for(m=1;m<=5;m++)
	{
		k=(int)Math.sqrt(Math.abs(m)+1);
		for(i=2;i<=k;i++)
		{
			if(m%i==0)
			{
				leap=0;
				break;
			}
		}
		if(leap!=0)
		{
			System.out.printf(""%-4d"",m);
			h++;
			if(h%10==0)
				System.out.printf(""\n"");
		}
		leap=1;
	}
	System.out.printf(""\nThe total is %d"",h);
}",['ABSI'],true,
1510,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 1;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],false,
1512,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian > 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1513,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['SEOD', 'VDL']",false,
1514,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length;  ) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AODS'],false,
1516,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; !(i < count); i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SEOI'],false,
1520,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a + b < c || a + c != b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['SEOR'],false,
1521,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a++ <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1522,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (++bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1523,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (false) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
1524,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
        return subarray;
    }",['AOIU'],false,
1526,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( --j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
1527,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex == array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
1531,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) / Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
1532,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x - x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1535,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength != 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['ROR'],false,
1538,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (false) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
1539,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b < c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1540,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[-i];
        data[i] = data[j];
        data[j] = tmp;
    }",['AOIU'],false,
1541,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength - offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
1543,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == ~codePoint) {
                return true;
            }
        }
        return false;
    }",['LOI'],false,
1544,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (false) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
1545,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength - offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
1547,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i--*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
1548,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x % x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1549,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'SEOD', 'VDL']",false,
1550,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian++ + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
1551,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c != b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1552,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( ++j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
1554,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
            return ISOSCELES;
        if (trian == 1) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD', 'VDL']",true,
1556,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (false) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }","['CDL', 'ROD', 'VDL']",false,
1558,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    ;
                }
            }
        }
        return buffer.toString();
    }",['FCDL'],false,
1561,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
            trian = trian % 2;
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
1564,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position == maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],true,
1566,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (false) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
1568,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first <= upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
1569,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound-- < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1570,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j == i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROR'],false,
1573,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
1574,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                 ;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ADL'],false,
1575,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (!(trian == 1 && a + b > c)) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
1577,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a + b < c || a + c < b || b / c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
1578,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
            return ISOSCELES;
        if (false && a + b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
1579,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
1580,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i%400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AORB'],true,
1581,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x++;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
1582,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition-- );
    }",['AOIS'],false,
1584,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff-- < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
1586,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint++ && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1587,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length + 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
1589,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x + N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
1590,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + ~c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
1591,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a + b < c || a * c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
1592,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( ~c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
1595,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c != maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],true,
1599,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 1) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
1600,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian >= 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1603,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
1604,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
            return ISOSCELES;
        if (trian == 1 && a / b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1605,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c++ > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1606,"public static int min(int I, int J)
{
	int Min;
    Min = I;
    if(J<=I) {
 	   Min=J;}
    return Min;
}",['ROR'],true,
1607,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (--trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1608,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive != array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
1610,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < -1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AOIU'],false,
1611,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length + 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
1613,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }","['AODU', 'ROD', 'SEOD', 'VDL']",true,
1614,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && !(c <= Character.MAX_LOW_SURROGATE)) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SEOI'],false,
1615,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( -position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIU'],false,
1616,"    public  int countTokens()
    {
        int count = 0;
        int currpos = -currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIU'],false,
1618,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse / y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1619,	public boolean removeNode(int nodeId),['CR'],false,
1620,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number++;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
1621,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= -1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
1623,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (false) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
1624,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c >= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
1625,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) <= mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
1626,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, -first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIU'],false,
1628,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
            if (trian == 2 && a / c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
1629,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b > c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1630,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, -1, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AOIU'],false,
1632,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (~a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
1633,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j]--;
                        a[j] = mytemp1;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
1635,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a++ == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1636,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
        if (b <= c) {
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['ROR'],false,
1637,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i---100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
1638,"    public  double sqrt( double N )
    {
        double x = -N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIU'],false,
1640,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, -data.length - 2 );
    }",['AOIU'],false,
1643,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = false ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }","['ROD', 'VDL']",false,
1644,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y % y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1646,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],true,
1649,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive * startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
1650,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = ++temp;
                }
            }
        }
    }",['AOIS'],false,
1651,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (true && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
1654,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (true) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'CDL', 'ROD', 'SEOD', 'VDL']",false,
1655,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex > array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
1656,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1;; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROD'],false,
1657,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < ~a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
1658,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower--, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORS'],false,
1659,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && ++error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1661,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= -1) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
1665,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF != 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
1666,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= ~Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
1667,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint-- && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1670,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( --currentPosition );
        return newPosition < maxPosition;
    }",['AOIS'],false,
1672,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, -first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIU'],false,
1673,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse - x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1675,"    public  java.lang.String nextToken()
    {
        currentPosition = ++newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
1676,	public boolean removeNode(int nodeId),"['ROD', 'VDL']",false,
1677,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x % x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
1678,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position--) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1680,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 0;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['CR'],false,
1681,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || !(b <= 0) || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
1682,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j <= i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROR'],false,
1684,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > -1) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],true,
1687,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x++;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
1688,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0;; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }","['ROD', 'VDL']",false,
1689,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) <= 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],true,
1690,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (false) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'CDL', 'ROD', 'VDL']",false,
1691,"    public  void sort( int[] data )
    {
        for (int i = 0;; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }","['AORB', 'CDL', 'ROD', 'VDL']",false,
1693,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (false) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['VDL'],false,
1694,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || ++b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1695,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length * 2 );
    }",['AORB'],false,
1696,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i]++;
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
1697,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive / startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
1700,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon--) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
1701,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; false; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['ROD', 'VDL']",true,
1702,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? ~newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['LOI'],false,
1705,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 1) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],false,
1706,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (!(c <= maxDelimCodePoint) && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOI'],false,
1709,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                    return ISOSCELES;
                if (trian == 3 && b / c > a) {
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1710,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt * 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
1711,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
            if (a + b < c || a + c < b || b + c < a) {
        if (trian >= 0) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1714,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = -1; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['AOIU'],false,
1715,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (false) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
1716,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize < 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
1717,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while (false) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'VDL']",false,
1718,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (!(diff > 0)) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['SEOI'],false,
1719,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 1) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
1720,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (~c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
1721,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex <= 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
1723,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y > -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['ROR'],false,
1724,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
                return ISOSCELES;
            if (trian == 2 && a / c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1725,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( ~position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
1728,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (true) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['VDL'],false,
1729,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = --x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
1730,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
             ;
        }
        return count;
    }",['ADL'],false,
1731,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (true) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['VDL'],false,
1734,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c--;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
1735,"    public  double sqrt( double N )
    {
        double x = N;
        double M = -N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIU'],false,
1736,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (true) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
1737,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (--c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1738,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c-- ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],true,
1740,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length / 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORB'],true,
1741,"    public static int gcd(int u, int v) {
        if (u * v <= 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],false,
1742,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || --b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1744,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
            trian = trian + 0;
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['CR'],false,
1745,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
        return subarray;
    }",['AOIU'],false,
1746,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 0) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],false,
1747,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i++*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
1750,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x - x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1751,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint && !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['SEOR'],false,
1753,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == ++b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1754,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint || delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOR'],false,
1757,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c <= dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],true,
1759,"    public  double sqrt( double N )
    {
        double x = N--;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
1762,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= ~upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
1763,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c >= maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
1764,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (false) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
1765,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (--position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1767,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        trian = 1;
            trian = trian + 1;
        }",['CR'],false,
1768,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (!(upper + 1 < last)) {
            quicksort( data, upper + 1, last );
        }
    }",['SEOI'],false,
1770,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint || isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOR'],false,
1771,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = --x;
        mResult = r;
        return r;
    }",['AOIS'],false,
1772,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position--;
    }",['AOIS'],true,
1773,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return newPosition < --maxPosition;
    }",['AOIS'],false,
1774,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = ++trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1777,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position = Character.charCount( c );
                }
            }
        }
        return position;
    }",['VDL'],false,
1779,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 || a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOR'],false,
1780,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (true) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
1781,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x++;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
1786,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= --maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1787,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= -1) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
1788,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c != maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
1789,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count++];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
1790,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c == maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
1792,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[~j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['LOI'],false,
1793,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y % (z * z));
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1796,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return ~INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
1797,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= ++upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1798,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength / offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
1799,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength * offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
1801,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( ++i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
1802,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize == 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
1803,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j-- > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
1805,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c++ <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1807,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 1, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['CR'],false,
1808,"    public  void setEpsilon( double epsilon )
    {
        this.mEpsilon = --epsilon;
    }",['AOIS'],false,
1810,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( ~c );
                }
            }
        }
        return position;
    }",['LOI'],false,
1811,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
        }
            trian = trian - 2;
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1813,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; ++i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
1814,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() + 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AORB'],false,
1815,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + -8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AOIU'],false,
1816,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request != 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
1817,	public boolean removeNode(int nodeId),['ROR'],true,
1819,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) >= mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
1820,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( ~currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['LOI'],false,
1822,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > --i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
1823,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (--c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
1824,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
        if (a <= 0 || b <= 0 || c == 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['ROR'],false,
1825,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return false;
    }","['ROD', 'VDL']",false,
1826,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i++ < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
1827,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters != null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
1829,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((true) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }","['AODU', 'ROD', 'VDL']",false,
1830,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && ~position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['LOI'],false,
1831,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position != maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
1832,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length / 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
1833,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) >= 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],false,
1834,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(1, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['CR'],false,
1835,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['ROD', 'SEOD', 'VDL']",false,
1836,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[-first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIU'],false,
1837,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + ~c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
1839,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
            if (trian == 2 && a * c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
1842,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( ~position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['LOI'],false,
1844,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],true,
1847,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) != 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
1848,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex <= 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
1851,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t != 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],false,
1854,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( ~position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
1855,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x++) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
1856,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian <= 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1857,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian * 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
1858,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || true) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD']",false,
1859,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e-- > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1860,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF++ > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1861,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length + 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
1863,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return !(newPosition < maxPosition);
    }",['SEOI'],false,
1864,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m--;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],true,
1865,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 0 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['CR'],false,
1866,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z / z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1867,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (!(a == b)) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
1868,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b-- < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1869,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length - 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AORB'],false,
1870,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (~b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
1872,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (true) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['SEOD', 'VDL']",false,
1873,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == ~c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
1874,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) > 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
1875,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (true) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'CDL', 'ROD', 'VDL']",false,
1876,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))	if(leap==1&&month-->2)
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}",['AOIS'],true,
1877,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
            return EQUILATERAL;
        if (false) {
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
1882,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (false) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }","['ROD', 'VDL']",false,
1883,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                if (trian == 3 && b - c > a) {
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
1884,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return newPosition == maxPosition;
    }",['ROR'],false,
1885,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = --temp;
                }
            }
        }
    }",['AOIS'],false,
1886,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 1; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['CR'],false,
1887,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                if (trian == 3 && b / c > a) {
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
1888,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (--M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
1889,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse % y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1890,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                    return ISOSCELES;
                if (trian == 3 && b + c >= a) {
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
1893,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(+inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1894,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r--;
    }",['AOIS'],true,
1895,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (true) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
1896,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive != 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
1897,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first - 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
1898,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
1899,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, -max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIU'],false,
1901,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = -x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIU'],false,
1902,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (++first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1906,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = -1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
1907,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 1);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],false,
1908,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c-- <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1909,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
1912,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition++) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1914,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && ~b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
1917,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c != Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
1918,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request++ == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1919,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD']",false,
1920,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a + b != c || a + c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['SEOR'],false,
1922,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3++ - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
1923,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) + ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AORB'],true,
1925,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i %= Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SAR'],false,
1926,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive <= 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],true,
1927,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
            trian = trian + 0;
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['CR'],false,
1930,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper % 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
1931,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper-- + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1933,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r--;
        return r;
    }",['AOIS'],false,
1935,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) % 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
1938,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (false) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
1940,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        ;
        return subarray;
    }",['FCDL'],false,
1941,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper / 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
1942,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = -temp;
                }
            }
        }
    }",['AOIU'],false,
1943,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length * 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
1944,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 + Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
1945,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength / offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
1946,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, ++upper + 1, last );
        }
    }",['AOIS'],false,
1948,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x * N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
1953,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = ~i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['LOI'],false,
1954,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper % 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
1955,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        ;
        return subarray;
    }",['FCDL'],false,
1956,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4<=0&&year%100!=0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}",['ROR'],true,
1957,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize == 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
1958,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; true; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }","['ROD', 'VDL']",false,
1959,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) < mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
1961,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 0);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['CR'],true,
1963,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > ~i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['LOI'],false,
1964,	public boolean removeNode(int nodeId),['AODU'],false,
1965,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos++ >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
1967,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i >= delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['ROR'],false,
1968,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u % 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
1969,"    public  void setEpsilon( double epsilon )
    {
        this.mEpsilon = epsilon++;
    }",['AOIS'],true,
1970,"public static void main(int b, int c, int d, int e, int f)",['AOIS'],true,
1971,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize == 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
1972,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] < codePoint) {
                return true;
            }
        }
        return false;
    }",['ROR'],false,
1973,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
1974,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; ~j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['LOI'],false,
1977,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && ++startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
1978,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (true) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
1980,"public static void main(int b, int c, int d, int e, int f)",['AOIS'],true,
1982,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive != 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
1983,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (--b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
1984,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength - offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
1985,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u + (1 << k); // gcd is u*2^k
    }",['AORB'],false,
1987,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (true) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
1988,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive <= 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
1989,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian-- + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
1990,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( -c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIU'],false,
1991,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & -1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],false,
1992,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a--) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
1993,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && true) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
1994,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper++) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
1997,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (false) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['VDL'],false,
1998,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == ++codePoint) {
                return true;
            }
        }
        return false;
    }",['AOIS'],false,
2001,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return 0;
    }",['VDL'],false,
2002,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (++trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2004,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
        return subarray;
    }",['CR'],false,
2005,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, 1, max );
        quicksort( data, 0, data.length - 2 );
    }","['AORB', 'VDL']",false,
2006,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && true) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
2007,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i > 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2008,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive >= array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
2009,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold <= 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['ROR'],true,
2010,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = ++x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
2013,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i == delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
2016,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length / 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
2017,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i <= length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],false,
2018,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
2019,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
2020,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
        if (a <= c) {
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['ROR'],false,
2021,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c < maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
2022,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c == a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2023,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= --maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
2025,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, ~first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
2026,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (!(a <= 0) || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
2027,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower > upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
2028,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return newPosition < ~maxPosition;
    }",['LOI'],false,
2029,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 1;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['CR'],false,
2032,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = ++x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
2033,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b++ == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2034,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() / 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AORB'],false,
2035,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) >= 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],false,
2036,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                    return ISOSCELES;
                if (false) {
                }
            }
        }
        return INVALID;
    }","['AORB', 'CDL', 'ROD', 'SEOD', 'VDL']",false,
2042,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( ++c );
            }
        }
        return position;
    }",['AOIS'],false,
2043,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse + x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
2046,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2047,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
2049,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
        return subarray;
    }",['CR'],false,
2050,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c < maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
2052,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < ++maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
2053,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                    return ISOSCELES;
                if (trian >= 3 && b + c > a) {
                }
            }
        }
        return INVALID;
    }",['ROR'],true,
2055,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
            trian = trian * 1;
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
2057,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex != 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2058,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, ~data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['LOI'],false,
2060,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = ~startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['LOI'],false,
2061,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c > a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2062,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
            if (a + b < c || a + c < b || b + c < a) {
        if (trian == 1) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['CR'],false,
2063,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1;
                        mytemp1 = mytemp2++;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
2064,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & -1) == 0 && (v & -1) == 0 && k < 3-1) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],false,
2065,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j * 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORB'],false,
2066,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper / 1, last );
        }
    }",['AORB'],false,
2072,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < ~maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
2073,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
2074,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i <= delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['ROR'],false,
2075,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return newPosition != maxPosition;
    }",['ROR'],false,
2076,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
            return ISOSCELES;
        if (trian >= 1 && a + b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2077,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = ++r;
        return r;
    }",['AOIS'],false,
2082,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos > position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
2084,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (false) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",true,
2086,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x / x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
2087,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive != array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
2088,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c < maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
2093,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k != 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],true,
2094,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos++ < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
2095,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 1) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['CR'],false,
2096,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
            return ISOSCELES;
        if (a + b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",true,
2098,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint-- && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
2099,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
2100,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( --c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
2101,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = 1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AODU'],false,
2105,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((true) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }","['AODU', 'ROD', 'VDL']",false,
2107,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+++(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
2108,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first++];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
2109,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] <= data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['ROR'],true,
2110,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && false) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['CDL', 'ROD', 'VDL']",false,
2111,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs( ++diff ) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
2112,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (false && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
2113,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, -first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIU'],false,
2114,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                    return ISOSCELES;
                if (trian == 3 && b % c > a) {
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2115,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i-- < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
2117,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c == 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2118,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[~lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
2121,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (true) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }","['CDL', 'ROD', 'VDL']",false,
2122,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = -1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AOIU'],false,
2123,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c++ )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
2124,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a-- <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2125,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position-- );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
2126,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c-- )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],true,
2127,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c <= b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2128,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF <= 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
2129,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 <= 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
2130,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j % 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORB'],true,
2131,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c-- )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
2134,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length + 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
2135,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
            trian = trian + 1;
        if (a >= b) {
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2136,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && true) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['CDL', 'ROD', 'VDL']",false,
2137,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos != maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['ROR'],false,
2138,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = --trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2139,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( --c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
2140,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
        }
            trian = trian + -3;
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
2141,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e++ > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
2143,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c++ ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],true,
2145,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j < i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROR'],false,
2147,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive / startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
2148,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 1; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
2149,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
        }
            trian = trian + -2;
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
2151,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[~upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
2153,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i---1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
2154,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex != 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2156,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'VDL']",false,
2157,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint-- || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
2158,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last++;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
2160,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position-- );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
2161,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind <= array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2162,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
        }
            trian = trian * 3;
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2164,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
2165,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF <= 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
2167,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x > -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['ROR'],false,
2169,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (true) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
2170,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( -position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIU'],false,
2171,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
        return subarray;
    }",['CR'],false,
2173,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c >= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
2174,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (false) {
                return true;
            }
        }
        return false;
    }","['ROD', 'VDL']",false,
2177,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD']",false,
2178,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + -1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AOIU'],false,
2179,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= -1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
2180,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos < maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['ROR'],false,
2181,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return ~EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
2182,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b * c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2184,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j--] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
2186,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || !(delimiters.indexOf( c ) < 0)) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['SEOI'],false,
2187,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && --error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
2188,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b++ || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2189,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['SEOD'],false,
2190,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a * b < c || a + c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2192,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF < 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
2193,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c == Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
2194,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (~trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
2195,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - -1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
2196,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (!(bound > data[lower])) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['SEOI'],false,
2197,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (true) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }","['ROD', 'VDL']",false,
2198,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a / b < c || a + c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
2199,"    private  int skipDelimiters( int startPos )
    {
        if (true) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
2200,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = +u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
2201,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive / startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
2202,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
        }
            trian = trian % 1;
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2203,"    public  void sort( int[] data )
    {
        for (int i = 0; i == data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROR'],false,
2208,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[-1], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['AOIU'],false,
2209,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (--trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2210,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1++;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
2212,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (false) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
2213,"  public Vector3D orthogonal() {

    double threshold = 0.6 % getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
2214,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
2215,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }","['ROD', 'SEOD', 'VDL']",false,
2216,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position > maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
2217,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
        }
            trian = trian % 3;
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2218,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, 1, last );
        }
    }","['AORB', 'VDL']",false,
2219,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold >= 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['ROR'],false,
2220,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + ~last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
2221,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first--];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
2222,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < ++upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
2224,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive + startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
2226,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                    return ISOSCELES;
                if (trian <= 3 && b + c > a) {
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2227,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive <= 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
2229,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
2230,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (++a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2231,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( ++We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
2232,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind <= array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2233,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower <= upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
2234,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (true || b <= 0 || c <= 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
2235,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a + b < c || a + c < b || b * c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
2237,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v >= 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],true,
2239,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (++bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
2244,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && !(a + c > b)) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
2245,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos >= maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['ROR'],false,
2246,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
            if (trian <= 2 && a + c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['ROR'],false,
2247,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian++ + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
2250,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m++ < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
2251,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower++ < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
2252,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c-- );
            }
        }
        return position;
    }",['AOIS'],true,
2254,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; true; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
2256,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
            trian = trian + 0;
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['CR'],false,
2257,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
2261,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0++ >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
2262,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex != 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2263,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || false || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'VDL']",false,
2264,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length;) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AODS'],false,
2265,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (true) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
2267,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            ;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ADL'],false,
2269,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 1) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],false,
2273,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i];
        data[i] = data[j++];
        data[j] = tmp;
    }",['AOIS'],false,
2274,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize < 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
2276,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 % Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
2278,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c++;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
2279,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= --maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
2282,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c++ ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],true,
2283,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return newPosition <= maxPosition;
    }",['ROR'],false,
2284,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength % offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
2286,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) <= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
2288,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position /= Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SAR'],false,
2289,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (~first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
2290,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return -position;
    }",['AOIU'],false,
2291,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 == ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
2293,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x % x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
2294,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && !(delimiters.indexOf( c ) >= 0)) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOI'],false,
2295,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (--a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2296,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (true) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['VDL'],false,
2299,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length + 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
2301,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) * Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
2302,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (false) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'VDL']",false,
2305,"    public  void sort( int[] data )
    {
        for (int i = 0; true; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }","['AORB', 'CDL', 'ROD', 'VDL']",false,
2306,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c >= a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2307,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (a == 0 || b <= 0 || c <= 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2308,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i == 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2310,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
        return subarray;
    }",['CR'],false,
2311,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r++;
        return r;
    }",['AOIS'],false,
2312,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (true) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }","['ROD', 'VDL']",false,
2313,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N--;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
2314,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition++ >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
2316,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position >= maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],true,
2317,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos <= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['ROR'],false,
2318,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c++ <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
2320,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex != 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2322,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
    	We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 % ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AORB'],true,
2323,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M-- + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
2324,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
            if (trian == 2 && a % c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
2325,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[++i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
2326,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 0;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
2327,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (--lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
2328,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind >= array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2329,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
2333,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
        if (trian == 1 && a / b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
2334,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (a <= 0 || b <= 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
2335,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last-- );
        }
    }",['AOIS'],true,
2337,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian++ == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2338,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
        }
            trian = trian + -1;
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
2339,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; ~i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
2340,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M % x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
2341,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position *= Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SAR'],false,
2342,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == --position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
2343,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i != count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],true,
2344,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x--) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
2345,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 >= last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
2351,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || false || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }","['CDL', 'ROD', 'VDL']",true,
2352,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) % 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
2355,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper % 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
2356,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (false) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
2357,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || --b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2358,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c < 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2359,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
2360,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos >= position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],true,
2361,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (true) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['ROD', 'SEOD', 'VDL']",false,
2363,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first == upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
2364,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (--trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2365,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
2366,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (false && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
2369,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive * startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
2370,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (true) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROD'],false,
2371,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind + tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
2372,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i%1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AORB'],true,
2374,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = ++i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
2375,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
            trian = trian + 2;
        if (false) {
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['ROD', 'VDL']",false,
2376,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos-- < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
2380,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = -1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
2381,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x - x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
2382,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos != position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
2384,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex > array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2387,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x == -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['ROR'],false,
2388,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) <= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
2391,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower >= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
2393,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = --x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
2394,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize == 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
2396,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength * offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
2398,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
        if (trian <= 0) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],true,
2399,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a % c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2400,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - -1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
2401,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c < maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
2402,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (true && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
2405,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return newPosition < ++maxPosition;
    }",['AOIS'],false,
2406,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c >= maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
2408,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e-- == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
2410,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, ~upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
2411,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; false; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['ROD', 'VDL']",false,
2412,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper - 1, last );
        }
    }",['AORB'],false,
2413,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i != length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],true,
2414,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a / b < c || a + c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2415,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) > 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
2416,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u - 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
2417,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = +t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
2418,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind >= array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2420,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    ;
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['FCDL'],false,
2422,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper * 1, last );
        }
    }",['AORB'],false,
2423,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + ++c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2424,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 0; i <= array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['ROR'],false,
2426,"    public static int gcd(int u, int v) {
        if (u * v == 1) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],false,
2427,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
            trian = trian % 3;
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
2428,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
2429,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (!isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['ROD', 'SEOD', 'VDL']",false,
2430,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength * 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],true,
2431,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper++ );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORS'],false,
2434,"public static void main(int b, int c, int d, int e, int f)",['AOIS'],true,
2436,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (false) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['ROD', 'SEOD', 'VDL']",false,
2437,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return -position;
    }",['AOIU'],false,
2438,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (false) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
2439,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max-- );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],true,
2440,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e-- == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
2441,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(abs(i)-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ABSI'],true,
2442,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex > array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2443,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (false) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }","['ROD', 'VDL']",false,
2444,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j % 1] = temp;
                }
            }
        }
    }",['AORB'],true,
2445,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m-- + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
2447,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
2448,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (-first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIU'],false,
2449,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position *= Character.charCount( c );
            }
        }
        return position;
    }",['SAR'],false,
2450,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u + 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
2451,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x++ - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
2452,"public static int min(int I, int J)
{
	int Min;
    Min = I++;
    if(J<I) {
 	   Min=J;}
    return Min;
}",['AOIS'],true,
2453,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
2454,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
        if (a <= 0 || b == 0 || c <= 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['ROR'],false,
2455,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != -1);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],false,
2456,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint || delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOR'],false,
2459,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j++] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
2461,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize == 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
2462,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a % b < c || a + c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2463,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
2464,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind % tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
2465,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; --i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
2466,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
2468,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }","['SEOD', 'VDL']",false,
2469,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 0)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],false,
2470,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || !(a + c < b) || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
2472,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N++;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
2473,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + ++b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2476,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 > ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
2477,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'SEOD', 'VDL']",false,
2478,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff >= 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
2479,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition++) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
2480,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x++ - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
2482,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (~a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
2483,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b != c || a + c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2484,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t ^ 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['LOR'],false,
2485,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex != 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2486,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c >= dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],true,
2489,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        ;
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['FCDL'],false,
2491,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c--) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
2492,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'VDL']",false,
2493,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b++ < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2494,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && --position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
2496,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c <= a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2497,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = -currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIU'],false,
2498,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = Math.abs(a[2]);
        if (number >= end) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['ABSI'],true,
2502,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] >= number) {
                    mytemp1 = a[i];
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['ROR'],true,
2503,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition++ : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
2504,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return ++newPosition < maxPosition;
    }",['AOIS'],false,
2506,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && ++c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
2508,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && ++error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
2509,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, first + last + 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
2510,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos++;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],true,
2512,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < -1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
2516,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b++ + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
2518,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < ~upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
2519,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( -position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIU'],false,
2520,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return 0;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['VDL'],false,
2522,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp--;
                }
            }
        }
    }",['AOIS'],true,
2523,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( ~currpos );
            count++;
        }
        return count;
    }",['LOI'],false,
2524,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && ~a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
2526,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = ~currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['LOI'],false,
2527,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && --confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
2530,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + ++x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
2531,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian % 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2532,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i---600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
2534,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],true,
2537,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = ~trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
2539,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i *= Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SAR'],false,
2541,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c++ ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],true,
2542,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (--currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
2543,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && ++position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
2544,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i++ < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
2545,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
2546,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 0;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
2548,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position--;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AORS'],false,
2549,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = ~first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
2550,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100>0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}",['ROR'],true,
2551,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c-- );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],true,
2554,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (!(c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0)) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOI'],false,
2555,"    public  void sort( int[] data )
    {
        if (data.length != 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['ROR'],false,
2556,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( --c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
2558,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex > array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2560,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive != array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
2561,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c++ > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
2562,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b >= c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2563,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= ++maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
2564,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( --c );
            }
        }
        return position;
    }",['AOIS'],false,
2565,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position++;
    }",['AOIS'],true,
2567,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 >>> k); // gcd is u*2^k
    }",['SOR'],false,
2568,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < -1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
2569,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; ++i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['AOIS'],false,
2571,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos > maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['ROR'],false,
2573,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = abs(We1_BA_DEF_ev_ctr2) * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ABSI'],true,
2575,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, -upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIU'],false,
2577,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M / x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
2578,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 <= last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
2579,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition++) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
2581,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; !(j > i); --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['SEOI'],false,
2582,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i++-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
2583,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( --We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
2585,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (!(data[max] < data[i])) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['SEOI'],false,
2586,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position > maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],true,
2587,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b == c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2588,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= ++maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
2589,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper--) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
2590,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD']",false,
2591,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && !(position < maxPosition)) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['SEOI'],false,
2592,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b-- > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2593,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex > array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2595,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (++c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
2597,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return -ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
2598,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, ++upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
2599,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number--;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
2600,"public static int min(int I, int J)
{
	int Min;
    Min = I;
    if(J<I) {
 	   Min=J++;}
    return Min;
}",['AOIS'],true,
2601,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t | 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['LOR'],false,
2602,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length * 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
2603,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= -1; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
2604,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e == 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
2605,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 / ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AORB'],true,
2606,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a >= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2607,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( -j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIU'],false,
2608,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian < 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2609,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= +threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
2611,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (false) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
2612,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 0) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['CR'],false,
2613,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                ;
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['FCDL'],false,
2615,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
2616,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < -1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
2617,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c != maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
2618,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position %= Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SAR'],false,
2619,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return ~position;
    }",['LOI'],false,
2620,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i];
        data[i] = data[++j];
        data[j] = tmp;
    }",['AOIS'],false,
2621,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (true) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROD'],false,
2625,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian-- == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2627,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOD'],false,
2628,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (!(a <= 0 || b <= 0) || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
2629,"    private  int scanToken( int startPos )
    {
        int position = startPos--;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
2630,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - -1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
2631,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (true) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }","['ROD', 'SEOD', 'VDL']",false,
2632,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
2637,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (true) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
2639,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters != null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
2641,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive * startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
2642,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = -trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
2644,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
2645,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() * 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AORB'],false,
2646,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos != maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['ROR'],false,
2647,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (--currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
2649,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind / tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
2651,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
2652,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 * Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
2654,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b - c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2655,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = ~u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['AODU', 'LOI']",false,
2656,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition--) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
2657,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) == 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
2658,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
        if (trian > 0) {
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['CR'],false,
2662,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m == c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
2663,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length + 2 );
    }",['AORB'],false,
2664,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (--first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
2665,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || false) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }","['CDL', 'ROD', 'VDL']",false,
2667,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c >= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
2669,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b-- == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2670,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length / 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
2671,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        ;
        return subarray;
    }",['FCDL'],false,
2672,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt > offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['ROR'],true,
2675,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end++) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
2676,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400<=0||(year%4==0&&year%100!=0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}",['ROR'],true,
2677,"    public  void sort( int[] data )
    {
        for (int i = 0; ++i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
2678,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( --c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
2682,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive != 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
2683,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c-- <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
2684,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / -2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIU'],false,
2687,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( ++c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
2689,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( --c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
2690,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i--) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['AORS'],false,
2692,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y / y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
2693,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x - z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
2695,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length / 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
2696,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (false) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
2697,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * --We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
2701,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'SEOD', 'VDL']",false,
2702,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request <= 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
2704,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && --startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
2705,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                ; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ADL'],false,
2707,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == --We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
2711,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind >= array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2714,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = -abs(We1_BA_DEF_ev_ctr2) * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ABSI'],true,
2715,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
                return ISOSCELES;
            if (trian == 0 && a + c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['CR'],false,
2716,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * ++x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
2718,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
            return EQUILATERAL;
        if (trian > -3) {
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
2719,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count;) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }","['AODS', 'VDL']",false,
2720,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (false) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
2722,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (false) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }","['ROD', 'VDL']",false,
2724,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e-- > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
2726,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= -1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
2727,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = M + x - 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
2728,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(1);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['CR'],false,
2729,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
            trian = trian * 2;
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
2730,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF++ > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
2731,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (!(c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE)) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SEOI'],false,
2733,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a == 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2736,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y * (z * z));
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
2738,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 1) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
2739,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian != 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2740,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position++ );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
2741,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e < 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
2744,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i];
        data[i] = data[-j];
        data[j] = tmp;
    }",['AOIU'],false,
2745,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper, last );
        }
    }","['AORB', 'CDL']",false,
2746,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e >= 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
2747,"    public static int gcd(int u, int v) {
        if (u + v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
2748,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                 ;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ADL'],false,
2751,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x++) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
2752,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (~trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
2753,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex > array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2754,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i++-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
2755,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                    return ISOSCELES;
                if (trian == 3 && b + c != a) {
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2756,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( -i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIU'],false,
2757,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 1) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['CR'],true,
2760,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max++ );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],true,
2762,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse + x, 0);

  }",['AORB'],false,
2767,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a * b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2769,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (false) {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }","['ROD', 'VDL']",false,
2770,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( --ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
2771,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[1] = temp;
                }
            }
        }
    }",['AORB'],false,
2774,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = ++x;
        mResult = r;
        return r;
    }",['AOIS'],false,
2777,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=abs(i)*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ABSI'],true,
2778,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(-1);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AOIU'],false,
2780,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian < 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2782,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c && a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOR'],false,
2783,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max++] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
2784,"    public static int gcd(int u, int v) {
        if (u % v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
2785,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a - c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2787,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - -1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AOIU'],false,
2788,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c++ <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2789,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= ++maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
2790,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && --b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2791,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u ^ 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['LOR'],false,
2792,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a / c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2793,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (false) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
2794,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
        }
            trian = trian + 0;
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['CR'],false,
2795,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e <= 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
2796,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (!(trian == 2) && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
2797,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (false) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'VDL']",false,
2798,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() % 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AORB'],false,
2799,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
            trian = trian - 2;
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
2800,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian >= 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2801,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) * 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
2802,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (!(retDelims && startPos == position)) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOI'],false,
2804,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z % z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
2806,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; true; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
2807,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( ~position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['LOI'],false,
2808,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i == 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2809,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c++ );
                }
            }
        }
        return position;
    }",['AOIS'],true,
2810,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse % x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
2811,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt / 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
2812,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (++M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
2813,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] >= data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROR'],false,
2820,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
2821,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (++c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
2822,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound >= data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
2823,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (false) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }","['ROD', 'VDL']",false,
2824,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
                return ISOSCELES;
            if (trian == 2 && a + c >= b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2826,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (false) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }","['CDL', 'ROD', 'VDL']",false,
2827,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || a + c < b || b / c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2828,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[~j - 1] = temp;
                }
            }
        }
    }",['LOI'],false,
2829,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (~bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
2830,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a / b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2831,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position != maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
2833,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c >= a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2834,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse - y, -inverse * x, 0);

  }",['AORB'],false,
2836,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i%100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AORB'],true,
2837,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (true) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
2838,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a++ + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2843,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || a + c != b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2844,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                 ;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ADL'],false,
2845,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (true) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }","['CDL', 'ROD', 'VDL']",false,
2848,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (~c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['LOI'],false,
2850,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count--;
        }
        return count;
    }",['AORS'],false,
2852,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i++]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
2857,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i == 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2859,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] != data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['ROR'],false,
2860,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'CDL']",false,
2861,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (a <= 0 || c <= 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
2862,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
                return ISOSCELES;
            if (trian == -2 && a + c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
2863,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind >= array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2864,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (--c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
2865,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = -1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
2866,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = -startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIU'],false,
2869,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (false && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
2870,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian >= 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2871,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (true) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
2872,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + ~b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
2873,"    public  double sqrt( double N )
    {
        double x = N++;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
2874,"  public Vector3D orthogonal() {

    double threshold = -0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AOIU'],false,
2875,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
2876,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (!(c <= maxDelimCodePoint && isDelimiter( c ))) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOI'],false,
2877,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first-- );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
2879,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * --x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
2880,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
2881,	public boolean removeNode(int nodeId),['ROR'],true,
2882,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; true; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
2883,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
            trian = trian + 3;
        if (b <= c) {
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2885,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength % offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
2890,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c-- > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
2891,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                    return ISOSCELES;
                if (trian == -3 && b + c > a) {
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
2892,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c-- < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2893,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (!hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SEOI'],false,
2894,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length % 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AORB'],true,
2895,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ROR'],true,
2897,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == --codePoint) {
                return true;
            }
        }
        return false;
    }",['AOIS'],false,
2898,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i > delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['ROR'],false,
2899,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
        return subarray;
    }",['CR'],false,
2900,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c-- )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
2901,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x--;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
2903,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b <= c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2904,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
        }
            trian = trian - 1;
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2906,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (--diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
2907,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i++] == codePoint) {
                return true;
            }
        }
        return false;
    }",['AOIS'],false,
2909,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || ~b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
2910,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < --maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
2911,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
2912,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u / (1 << k); // gcd is u*2^k
    }",['AORB'],false,
2913,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a * b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2915,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex == array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2917,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == -1) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AOIU'],false,
2918,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD', 'VDL']",false,
2920,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = M + x;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }","['AORB', 'CDL']",false,
2922,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < ~count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
2925,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c < a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2926,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian * 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2927,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x--;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
2929,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper--]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
2932,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < ~maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['LOI'],false,
2933,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (true) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
2934,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; ~i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['LOI'],false,
2936,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (~a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
2937,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a > 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
2939,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
        if (trian == 0 && a + b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['CR'],false,
2940,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a + b <= c || a + c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['ROR'],false,
2941,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (~first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
2943,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( --i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
2944,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c != Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
2945,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                if (trian == 3 && b % c > a) {
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
2948,"    public static int gcd(int u, int v) {
        if (u * v == -1) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],false,
2949,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
2950,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos-- >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
2951,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (true) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
2952,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 0) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['CR'],false,
2953,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c++) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
2958,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = -1;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AOIU'],false,
2959,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive >= array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
2960,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < -1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],true,
2962,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j %= Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SAR'],false,
2963,"	public void addNode(int id, int rate, int coverage, int xPosition,",['SEOR'],false,
2965,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD']",false,
2966,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (~c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
2967,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x - x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
2968,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                    return ISOSCELES;
                if (trian == 3 && b * c > a) {
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
2970,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 0;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['CR'],false,
2971,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 > ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
2972,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length * 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
2974,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 0;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['CR'],false,
2975,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; true; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
2976,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && true) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD']",false,
2978,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m != c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
2979,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( -currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIU'],false,
2980,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (++a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2982,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( --currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
2983,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length * 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
2984,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (true || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
2985,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex == array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
2986,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORB'],true,
2987,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff > 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
2988,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < ++c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
2989,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (!(diff < 0)) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['SEOI'],false,
2990,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = ++trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
2991,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = -c;
            }
        }
    }",['AOIU'],false,
2992,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (!(currpos < maxPosition)) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['SEOI'],false,
2993,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
            if (a + b < c || a + c < b || b + c < a) {
        if (false) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
2994,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
2995,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e <= 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
2997,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u - (1 << k); // gcd is u*2^k
    }",['AORB'],false,
2999,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (false) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
3000,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c++;
            }
        }
    }",['AOIS'],false,
3001,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i > 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3002,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i];
        data[i] = data[j];
        data[j] = --tmp;
    }",['AOIS'],false,
3003,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (!(lower < upper)) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['SEOI'],false,
3004,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( ~c );
            }
        }
        return position;
    }",['LOI'],false,
3005,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && false) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
3007,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < -1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
3008,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = --c;
            }
        }
    }",['AOIS'],false,
3009,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (--m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
3010,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 1) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
3012,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition++;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
3013,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && true) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }","['ROD', 'VDL']",false,
3015,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (++m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
3018,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, -last );
        }
    }",['AOIU'],false,
3019,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start--, currentPosition );
    }",['AOIS'],true,
3020,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[--upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3023,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a++ + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3024,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (!(m < c)) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SEOI'],false,
3025,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > ~b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
3027,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length + 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AORB'],false,
3028,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, ~upper + 1, last );
        }
    }",['LOI'],false,
3032,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m-- < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
3033,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return ~INVALID;
    }",['LOI'],false,
3034,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y / y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3036,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) * 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3037,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( -position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIU'],false,
3039,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > ++maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
3040,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last++ );
        }
    }",['AOIS'],true,
3041,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while (false && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
3042,"	public static int main( int a, int b, int c ) {
		int mid;
		if (a < b) {
			if (c < b) {
				if (a < c) {
					mid = c;
				} else {
					mid = a;
				}
			} else {
				mid = b;
			}
		} else {
			if (c >= b) {
				if (a > c) {
					mid = c;
				} else {
					mid = a;
				}
			} else {
				mid = b;
			}
		}
		return mid;
	}",['ROR'],true,
3044,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound >= data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
3045,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=abs(bonus6)+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ABSI'],true,
3047,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i == 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3050,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[++max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
3051,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a++) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
3052,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x++ * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
3053,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c != b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3054,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive * startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
3055,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian <= 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3056,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3057,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < --count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
3059,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition-- >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
3061,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (false) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }","['AORB', 'CDL', 'ROD', 'VDL']",false,
3063,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a / b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3064,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = ++c;
            }
        }
    }",['AOIS'],false,
3065,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 1) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['CR'],false,
3066,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
3067,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v / u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
3068,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs( diff-- ) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
3069,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && false) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD']",false,
3070,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( -c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIU'],false,
3072,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],true,
3073,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind >= array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3074,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!(!retDelims && position < maxPosition)) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['SEOI'],false,
3075,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[~j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['LOI'],false,
3076,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a <= b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3078,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper / 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
3079,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return """";
    }",['VDL'],false,
3080,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c == maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],true,
3081,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length * 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AORB'],true,
3082,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length / 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
3085,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian != 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3087,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && ~startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
3088,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
        if (b >= c) {
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['ROR'],false,
3089,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = ++x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
3091,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; --i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
3092,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; false; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }","['ROD', 'VDL']",false,
3093,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] >= data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['ROR'],false,
3094,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c-- > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
3095,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( -position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIU'],false,
3097,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first - last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
3098,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= --upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3099,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 1);

  }",['CR'],false,
3100,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + -32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AOIU'],false,
3101,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
            if (trian == 2 && a + c != b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['SEOR'],false,
3102,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower >= upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
3103,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(1, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['CR'],false,
3104,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < ~last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
3105,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[++lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3112,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['SEOD', 'VDL']",false,
3114,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'VDL']",false,
3115,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 0;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['CR'],false,
3116,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
            return EQUILATERAL;
        if (trian > 0) {
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['CR'],false,
3120,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c++ > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
3122,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k >= 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],true,
3123,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i > 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3124,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a++ + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3126,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 % Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3128,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive >= array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
3129,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (true) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD']",false,
3133,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || ~b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
3134,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff <= 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
3135,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || true || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD']",false,
3137,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return 0;
    }",['VDL'],false,
3138,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first % last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
3141,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (!(currentPosition >= maxPosition)) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['SEOI'],false,
3142,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i >= length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],true,
3146,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i---400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
3147,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (false) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }","['ROD', 'VDL']",false,
3148,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive + startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
3149,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
        if (a <= 0 || b <= 0 || c < 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['ROR'],false,
3150,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x / x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3151,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (!(c <= maxDelimCodePoint) && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOI'],false,
3152,"    public  void sort( int[] data )
    {
        for (int i = 0; ~i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['LOI'],false,
3153,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
        if (trian <= 1 && a + b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['ROR'],true,
3155,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e >= 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
3157,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 1) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['CR'],false,
3158,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind / tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
3159,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (~trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
3160,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || !(c <= 0)) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
3162,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == ~c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
3163,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a-- + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3164,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length % 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AORB'],false,
3165,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a != b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3166,"public static void main(int b, int c, int d, int e, int f)",['AOIS'],true,
3167,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + --x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
3168,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
            trian = trian / 3;
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
3169,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (false) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
3170,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c-- );
                }
            }
        }
        return position;
    }",['AOIS'],true,
3171,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = --m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
3172,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] == data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['ROR'],false,
3173,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 0 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['CR'],true,
3174,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition++ );
        return str.substring( start, currentPosition );
    }",['AOIS'],true,
3175,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive + startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
3178,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i > 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3180,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition++;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
3183,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? 0 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['AODU'],false,
3185,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
        return subarray;
    }",['AOIU'],false,
3187,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return -INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
3188,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (true) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['SEOD', 'VDL']",false,
3189,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (true && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
3191,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower++ <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3192,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse % y, -inverse * x, 0);

  }",['AORB'],false,
3194,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive <= 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
3196,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c >= escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],true,
3197,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive != array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
3199,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (false) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['VDL'],false,
3204,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            ; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ADL'],false,
3205,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex > array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3206,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( ++i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
3207,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > ++mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
3208,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == codePoint--) {
                return true;
            }
        }
        return false;
    }",['AOIS'],false,
3209,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3210,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( -currentPosition );
        return newPosition < maxPosition;
    }",['AOIU'],false,
3212,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))	if(leap==1&&month++>2)
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}",['AOIS'],true,
3213,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind * tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
3214,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length / 2 );
    }",['AORB'],false,
3215,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= ~maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['LOI'],false,
3216,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (++currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
3219,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF < We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
3221,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c <= b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3222,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) == 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
3223,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k <= 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],true,
3224,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['ROD', 'SEOD', 'VDL']",false,
3225,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                if (trian == 3 && b + c != a) {
                }
            }
        }
        return INVALID;
    }

}",['SEOR'],false,
3226,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = -x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIU'],false,
3228,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
3229,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x + x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3230,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i++-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
3233,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x / (z * z));
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3234,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first++, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3235,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        if (a == b) {
        trian = -1;
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
3238,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
            if (trian == 0 && a + c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['CR'],false,
3239,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
                return ISOSCELES;
            if (trian == 2) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD', 'VDL']",true,
3240,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (!(c > maxDelimCodePoint || delimiters.indexOf( c ) < 0)) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['SEOI'],false,
3241,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (!(b == c)) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
3242,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
3245,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind <= array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3248,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (true) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
3249,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower--;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORS'],false,
3250,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims || position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['SEOR'],false,
3251,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b != c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3252,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[~j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['LOI'],false,
3254,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (b <= 0 || c <= 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
3255,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i >= data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['ROR'],false,
3256,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + --c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3259,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e != 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
3260,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; true; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
3262,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i == 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3263,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 - We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AORB'],true,
3264,"    public static Map toMap(Object[] array) {
        if (false) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }","['ROD', 'VDL']",false,
3266,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
                return ISOSCELES;
            if (trian == 2 && a - c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3267,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 1) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
3269,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, first + last - 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
3270,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ROR'],true,
3271,	public boolean removeNode(int nodeId),"['AODU', 'CDL', 'ROD', 'VDL']",false,
3272,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint-- && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
3273,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c >= dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],true,
3274,"	public static void main(String args[])
{
	int m,i,k,h=0,leap=1;
	System.out.print(""\n"");
	for(m=1;m<=5;m++)
	{
		k=(int)Math.sqrt(m/1);
		for(i=2;i<=k;i++)
		{
			if(m%i==0)
			{
				leap=0;
				break;
			}
		}
		if(leap!=0)
		{
			System.out.printf(""%-4d"",m);
			h++;
			if(h%10==0)
				System.out.printf(""\n"");
		}
		leap=1;
	}
	System.out.printf(""\nThe total is %d"",h);
}",['AORB'],true,
3277,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length % 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
3278,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y % y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3279,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i---200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
3281,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (true) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }","['ROD', 'VDL']",false,
3282,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e <= 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
3283,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return -EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
3284,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[--j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
3285,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( ~i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
3286,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (!(c > maxDelimCodePoint) || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['SEOI'],false,
3287,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (false || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }","['ROD', 'VDL']",false,
3288,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition != 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['ROR'],false,
3289,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position++;
    }",['AOIS'],true,
3290,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return -SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
3292,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
            return ISOSCELES;
        if (trian == 1 && a + b >= c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3293,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian < 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3294,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m <= c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],true,
3295,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                 ;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ADL'],false,
3297,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1;  ) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AODS'],false,
3298,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (!(a + b < c || a + c < b) || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
3299,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (false) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
3300,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i];
        data[~i] = data[j];
        data[j] = tmp;
    }",['LOI'],false,
3301,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 1; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
3302,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c-- <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
3303,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i-- < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
3304,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex == array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3305,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (true)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }","['ROD', 'VDL']",false,
3307,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c < Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
3308,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() % 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AORB'],false,
3309,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF-- == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
3316,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i == 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3317,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD']",false,
3318,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) + ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AORB'],true,
3319,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
3320,"    public  java.lang.String nextToken()
    {
        currentPosition = !(newPosition >= 0 && !delimsChanged) ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['SEOI'],false,
3322,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 * Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3323,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year--%100!=0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}",['AOIS'],true,
3325,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first * 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
3327,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, -upper + 1, last );
        }
    }",['AOIU'],false,
3328,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position++ );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
3329,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= -1) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
3334,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower < upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
3335,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'SEOD', 'VDL']",true,
3336,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive * startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
3337,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= ++maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
3338,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > -1) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],true,
3339,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c != 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3340,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 0;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['CR'],false,
3341,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = ++We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
3343,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
3346,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position--;
    }",['AOIS'],true,
3347,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i--, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AORS'],false,
3349,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( ++c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
3351,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < -1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
3353,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return newPosition < maxPosition--;
    }",['AOIS'],false,
3354,"  public Vector3D orthogonal() {

    double threshold = 0.6 - getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3355,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length / 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AORB'],false,
3357,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive + startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
3358,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 0;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
3359,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2-- * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
3360,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y - y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3361,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M++ + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
3362,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint++ && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
3363,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
3364,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && ++b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3365,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length + 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
3367,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt > 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['ROR'],true,
3368,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 || b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOR'],false,
3372,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        ;
        return subarray;
    }",['FCDL'],false,
3373,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) * 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
3374,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c < Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
3375,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
        return subarray;
    }",['AOIU'],false,
3377,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a != c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3379,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (--a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3380,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request++ > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
3381,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[-1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['AOIU'],false,
3383,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + ~c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
3384,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = -1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
3385,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( -c );
                }
            }
        }
        return position;
    }",['AOIU'],false,
3386,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (true && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
3388,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (false && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['ROD', 'VDL']",false,
3389,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( --currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
3390,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian / 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3393,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                ;
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['FCDL'],false,
3395,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
                return ISOSCELES;
            if (trian == 2 && a % c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3397,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x++ * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
3398,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a % b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3400,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ~ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
3401,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first != upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
3404,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first++ + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3406,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (false) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }","['CDL', 'ROD', 'VDL']",false,
3407,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (true) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
3411,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j++ - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
3412,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (true) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'SEOD', 'VDL']",false,
3414,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= -1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
3416,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = -1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AOIU'],false,
3418,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = -x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIU'],true,
3419,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian >= 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3420,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower--;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORS'],false,
3421,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && ++a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3423,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
3425,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c != maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
3428,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
3432,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 1) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
3433,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3434,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v ^ 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['LOR'],false,
3435,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first--, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3436,"	public static void main(String args[])
{
	int m,i,k,h=0,leap=1;
	System.out.print(""\n"");
	for(m=1;m<=5;m++)
	{
		k=(int)Math.sqrt(m+1);
		for(i=2;i<=k;i++)
		{
			if(m%i==0)
			{
				leap=0;
				break;
			}
		}
		if(leap!=0)
		{
			System.out.printf(""%-4d"",Math.abs(m));
			h++;
			if(h%10==0)
				System.out.printf(""\n"");
		}
		leap=1;
	}
	System.out.printf(""\nThe total is %d"",h);
}",['ABSI'],true,
3437,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + ++x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
3439,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AOIU'],false,
3440,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
3441,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= -1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
3443,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3444,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (true || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
3445,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF++ == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
3447,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (true) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
3448,"	public void addNode(int id, int rate, int coverage, int xPosition,",['ADL'],false,
3449,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['SEOD'],false,
3450,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=abs(bonus2)+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ABSI'],true,
3451,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length % 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
3452,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (true || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD']",false,
3454,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 - Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3455,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'CDL']",false,
3456,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize == 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
3457,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (~a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
3458,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position-- < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
3459,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper++ + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3460,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (++trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3461,"    public  void sort( int[] data )
    {
        for (int i = 0; i++ < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
3462,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition++ );
    }",['AOIS'],false,
3463,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 != last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
3465,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind >= array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3467,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (true && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }","['ROD', 'VDL']",false,
3468,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j];
                    data[j - 1] = temp;
                }
            }
        }
    }","['AORB', 'CDL']",true,
3469,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1--;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
3472,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i];
        data[i] = data[j--];
        data[j] = tmp;
    }",['AOIS'],false,
3476,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 0;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],false,
3477,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 0) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],false,
3478,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian-- == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3479,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (++c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
3480,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos++ );
            count++;
        }
        return count;
    }",['AOIS'],true,
3481,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c++ > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
3482,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2-- - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
3483,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                if (trian == 3 && b * c > a) {
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
3484,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e != 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
3485,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[~i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['LOI'],false,
3486,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos-- );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],true,
3487,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return newPosition++ < maxPosition;
    }",['AOIS'],false,
3488,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF != 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
3489,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (false && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
3490,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (false && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }","['ROD', 'VDL']",false,
3491,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(abs(i)-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ABSI'],true,
3492,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c++ < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3494,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + --c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3495,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i];
        data[i] = data[j];
        data[j] = tmp++;
    }",['AOIS'],true,
3498,"	public static void main(String args[])
{
	int m,i,k,h=0,leap=1;
	System.out.print(""\n"");
	for(m=1;m<=5;m++)
	{
		k=(int)Math.sqrt(m*1);
		for(i=2;i<=k;i++)
		{
			if(m%i==0)
			{
				leap=0;
				break;
			}
		}
		if(leap!=0)
		{
			System.out.printf(""%-4d"",m);
			h++;
			if(h%10==0)
				System.out.printf(""\n"");
		}
		leap=1;
	}
	System.out.printf(""\nThe total is %d"",h);
}",['AORB'],true,
3500,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, -1);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
3501,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
            trian = trian - 1;
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
3502,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c != a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3503,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return -INVALID;
    }",['AOIU'],false,
3505,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - -1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
3506,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && false) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD']",false,
3507,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive != array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
3510,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition++) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
3511,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == ++position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
3513,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind * tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
3514,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = -1; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['AOIU'],false,
3516,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (false) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
3518,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last--) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3519,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (false) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
3520,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a + b < c || a + c < b || b - c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
3522,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
3523,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'VDL']",true,
3524,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 - We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AORB'],true,
3525,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i];
        data[i] = data[~j];
        data[j] = tmp;
    }",['LOI'],false,
3527,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i--; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
3529,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= -1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
3530,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m % x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3531,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper++, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3532,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c == maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
3534,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (false || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['ROD', 'VDL']",false,
3536,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (true) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }","['CDL', 'ROD', 'VDL']",false,
3538,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian-- > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3540,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) >= ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['ROR'],false,
3541,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (!(trian > 3)) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
3542,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
3543,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i];
        data[i] = data[j];
        data[j] = ~tmp;
    }",['LOI'],false,
3544,"    public  void sort( int[] data )
    {
        for (int i = 0; i-- < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
3545,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff < 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
3546,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (!(first < upper - 1)) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['SEOI'],false,
3547,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = --c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
3549,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex <= 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3550,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i != 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],true,
3551,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j + 1] = temp;
                }
            }
        }
    }",['AORB'],true,
3552,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + ++c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3553,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 % Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3555,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c++ )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
3556,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = ~trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
3557,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
   return(abs(bonus));
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ABSI'],true,
3558,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u | 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['LOR'],false,
3559,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z - z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3560,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || true || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD']",false,
3561,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
             ;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ADL'],false,
3563,"	public static void main(String args[])
{
	int m,i,k,h=0,leap=1;
	System.out.print(""\n"");
	for(m=1;m<=5;m++)
	{
		k=(int)Math.sqrt(m+1);
		for(i=2;i<=k;i++)
		{
			if(m%i==0)
			{
				leap=0;
				break;
			}
		}
		if(leap!=0)
		{
			System.out.printf(""%-4d"",m);
			h++;
			if(h%10==0)
				System.out.printf(""\n"");
		}
		leap=1;
	}
	System.out.printf(""\nThe total is %d"",Math.abs(h));
}",['ABSI'],true,
3565,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= --maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
3566,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; true; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
3568,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = -trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
3569,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * abs(We1_BA_DEF_ev_ctr2) - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ABSI'],true,
3571,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c <= dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],true,
3572,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, ~upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
3574,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c <= escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],true,
3578,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    ;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ADL'],false,
3580,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e < 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
3582,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (!(trian == 3) && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
3583,"public static int min(int I, int J)
{
	int Min;
    Min = I;
    if(J<I) {
 	   Min=J;}
    return Min++;
}",['AOIS'],true,
3584,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (false) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
3587,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t < 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],false,
3589,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M * x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3590,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1--+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
3591,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a * c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3592,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while (false) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
3593,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (!(Math.abs( diff ) > mEpsilon)) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['SEOI'],false,
3594,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'VDL']",false,
3596,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 0;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
3597,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i;) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AODS'],false,
3598,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper--, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3601,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AORB'],true,
3602,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (++upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3603,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (true) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
3604,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3605,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(abs(i)-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ABSI'],true,
3606,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, +inverse * x, 0);

  }",['AORB'],false,
3607,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, -data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIU'],false,
3608,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length + 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
3609,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) != mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['SEOR'],false,
3610,"    public  void sort( int[] data )
    {
        if (data.length == 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['ROR'],false,
3611,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == --c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3613,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position-- < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
3614,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last--;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3615,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian >= 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3617,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition--) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
3618,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff >= 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
3619,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt % 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
3620,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i++ );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
3621,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= ~maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
3622,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position--;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AORS'],false,
3623,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
            return EQUILATERAL;
        if (trian >= 3) {
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3624,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
            if (trian >= 2 && a + c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['ROR'],false,
3625,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) % 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3626,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims || startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOR'],false,
3627,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1;
                        mytemp1 = mytemp2--;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
3629,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b-- + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
3630,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                    return ISOSCELES;
                if (trian == 3) {
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD', 'VDL']",true,
3631,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position++ );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
3633,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i == delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['ROR'],false,
3634,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= -1) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
3635,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( ++currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
3636,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition-- >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
3637,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return newPosition < maxPosition++;
    }",['AOIS'],false,
3638,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) >= 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],true,
3639,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition--;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],false,
3642,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( ~c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
3645,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (false) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
3646,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if (false) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }","['AODU', 'ROD', 'SEOD', 'VDL']",false,
3647,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition == 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['ROR'],false,
3649,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
        }
            trian = trian * 1;
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3653,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( -c );
            }
        }
        return position;
    }",['AOIU'],false,
3654,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian != 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3655,"	public void addNode(int id, int rate, int coverage, int xPosition,",['ROR'],false,
3656,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < -1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
3657,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (true) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
3658,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD']",false,
3659,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = -i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIU'],false,
3660,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + -1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AOIU'],false,
3661,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length / 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AORB'],true,
3662,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind <= array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3663,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first--, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],true,
3664,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind <= array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3666,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 0;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
3667,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return 0;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['VDL'],false,
3668,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (false) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }","['ROD', 'VDL']",false,
3669,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= -1) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
3670,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (--first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3672,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || ++a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3673,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
3674,"    public  void setEpsilon( double epsilon )
    {
        this.mEpsilon = -epsilon;
    }",['AOIU'],false,
3675,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian < 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3676,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 1) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
3677,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || a + c <= b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3678,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive * startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
3679,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m >= c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
3682,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff++ < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
3683,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = (false) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'VDL']",false,
3684,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v + u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
3685,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i%200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AORB'],true,
3686,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ROR'],true,
3687,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
        return subarray;
    }",['AOIU'],false,
3689,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        ;
        return subarray;
    }",['FCDL'],false,
3690,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c-- > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3693,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (~lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
3694,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M - x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3695,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || a + c < b) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD', 'VDL']",false,
3697,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
            trian = trian - 3;
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
3698,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e != 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
3699,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse + y, -inverse * x, 0);

  }",['AORB'],false,
3700,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - -1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
3701,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 1) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
3702,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[~count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
3703,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c > 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3704,"    public  void setEpsilon( double epsilon )
    {
        this.mEpsilon = ++epsilon;
    }",['AOIS'],false,
3705,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c == maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
3706,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x + x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3707,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while (false && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'VDL']",false,
3708,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j /= Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SAR'],false,
3709,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return +u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
3711,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i = Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['VDL'],false,
3712,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > ++maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
3713,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return -r;
    }",['AOIU'],false,
3714,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( -start, currentPosition );
    }",['AOIU'],false,
3715,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, --upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3719,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c >= b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3720,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[-j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIU'],false,
3721,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse - y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3725,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length % 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORB'],false,
3726,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (false) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
3727,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AORB'],true,
3728,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) % Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
3730,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (!(c > maxDelimCodePoint || !isDelimiter( c ))) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['SEOI'],false,
3731,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( -currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIU'],false,
3732,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b++) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3733,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (++c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
3737,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (!(delimiterCodePoints[i] == codePoint)) {
                return true;
            }
        }
        return false;
    }",['SEOI'],false,
3738,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian++ + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
3741,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( ~start, currentPosition );
    }",['LOI'],false,
3742,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3743,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (true) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'SEOD', 'VDL']",false,
3744,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b - c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3745,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) >= mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
3746,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive * startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
3747,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() >= 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['ROR'],false,
3751,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
        }
            trian = trian - 3;
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3753,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind <= array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3754,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - -1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
3756,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+++(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
3757,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (!(c > maxDelimCodePoint) || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['SEOI'],false,
3758,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3759,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (~lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
3761,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength * offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
3762,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian == 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3763,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a-- == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3765,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (--currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
3769,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }","['ROD', 'SEOD', 'VDL']",true,
3771,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < -1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
3772,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound < data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
3774,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x - y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3775,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian != 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3776,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = M + x + 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3777,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
                return ISOSCELES;
            if (false) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'CDL', 'ROD', 'SEOD', 'VDL']",false,
3780,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint-- && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
3781,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || ~c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
3782,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u % (1 << k); // gcd is u*2^k
    }",['AORB'],false,
3783,"    private  int scanToken( int startPos )
    {
        int position = -startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIU'],false,
3785,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= ++maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
3788,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i == 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3789,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive <= 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
3790,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i];
        data[i] = data[j];
        data[j] = ++tmp;
    }",['AOIS'],false,
3791,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex <= 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3794,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) > 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
3795,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = -r;
        return r;
    }",['AOIU'],true,
3796,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length % 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
3797,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
3798,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex <= 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3799,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (true) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['VDL'],false,
3801,"    public  java.lang.String nextToken()
    {
        currentPosition = ~newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['LOI'],false,
3802,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'CDL']",false,
3806,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(abs(i)-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ABSI'],true,
3807,"	public void addNode(int id, int rate, int coverage, int xPosition,",['FCDL'],false,
3809,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position++) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
3810,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c <= escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],true,
3811,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (false) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['ROD', 'VDL']",false,
3812,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen >= 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['ROR'],false,
3814,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && false) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'VDL']",false,
3815,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[--i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
3817,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (++position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
3818,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || a + c < b || b * c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3820,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, ~lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
3821,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
        return subarray;
    }",['AOIU'],false,
3822,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
3823,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || --a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3824,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
        }
            trian = trian / 1;
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3825,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
        if (trian >= 0) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3827,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (false) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'CDL', 'ROD', 'VDL']",false,
3828,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse + z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3830,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = -x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIU'],false,
3832,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c++) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3835,	public boolean removeNode(int nodeId),['FCDL'],false,
3836,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || --c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3837,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt == 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['ROR'],false,
3838,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() * 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AORB'],false,
3839,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (false && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
3840,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a--) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
3842,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian - 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3844,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b != 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3845,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive != array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
3846,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = false;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['SEOR'],false,
3847,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3848,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b < c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3851,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c <= a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3852,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
            trian = trian + 3;
        if (false) {
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['ROD', 'VDL']",false,
3854,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a * b < c || a + c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
3855,	public boolean removeNode(int nodeId),['AOIU'],false,
3857,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length + 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
3859,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (true) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
3861,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) == 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
3865,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b++ <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3866,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c >= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
3869,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['ROD', 'SEOD', 'VDL']",false,
3870,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b--) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3871,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 0;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['CR'],false,
3876,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = m + x + 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3877,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i];
        data[i] = data[j];
        data[j] = -tmp;
    }",['AOIU'],false,
3878,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < --maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
3879,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = ~last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
3880,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > -1) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],true,
3881,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < ~maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['LOI'],false,
3882,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
        if (trian == 1 && a + b != c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['SEOR'],false,
3885,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (false) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'VDL']",true,
3887,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == ~position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
3890,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position >= maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['ROR'],false,
3892,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength <= 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['ROR'],true,
3895,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > ++i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
3896,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) <= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
3897,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || a - c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3898,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == ++c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3899,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i == 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3903,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x / N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
3904,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( ~position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
3907,"    public  void sort( int[] data )
    {
        for (int i = 0; i != data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROR'],true,
3910,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length * 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AORB'],false,
3912,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e-- == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
3913,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = ~c;
            }
        }
    }",['LOI'],false,
3914,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position-- );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
3915,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= ~maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
3917,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( --confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
3918,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position++ );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
3919,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse / z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3920,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j != i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROR'],true,
3921,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive % startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
3923,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4--+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
3925,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs( --diff ) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
3926,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (false) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
3927,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y + y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3928,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x--;
        mResult = r;
        return r;
    }",['AOIS'],true,
3931,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(-1, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['AOIU'],false,
3933,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
3934,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == --b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3936,	public boolean removeNode(int nodeId),['ROR'],false,
3937,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = -c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIU'],false,
3938,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[~i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['LOI'],false,
3939,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && --confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
3941,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition++ );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['AOIS'],true,
3942,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e++ > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
3943,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }","['ROD', 'SEOD', 'VDL']",true,
3944,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i];
        data[i] = data[j];
        data[j] = tmp--;
    }",['AOIS'],true,
3947,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (true) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['ROD', 'SEOD', 'VDL']",false,
3949,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (--trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3951,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= -1) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],true,
3952,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i > 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3953,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
                return ISOSCELES;
            if (a + c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",true,
3954,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && !(a + b > c)) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
3955,"    public StringTokenizer( java.lang.String str, java.lang.String delim, boolean returnDelims )
    {
        currentPosition = 0;
        newPosition = 1;
        delimsChanged = false;
        this.str = str;
        maxPosition = str.length();
        delimiters = delim;
        retDelims = returnDelims;
        setMaxDelimCodePoint();
    }",['AODU'],false,
3956,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian < 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3958,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive % startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
3959,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (!(a + b < c || a + c < b || b + c < a)) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
3961,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                ;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['ADL'],false,
3962,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF != 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
3963,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (--bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
3965,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e != 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
3967,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length + 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
3968,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'SEOD', 'VDL']",true,
3969,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
                return ISOSCELES;
            if (trian == 2 && a + c != b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3970,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) * ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AORB'],true,
3971,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[-count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIU'],false,
3972,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[++j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
3973,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex > array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3975,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? 1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['AODU'],true,
3976,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, ~data.length - 2 );
    }",['LOI'],false,
3978,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a > c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
3979,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) >= 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
3980,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] > min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
3981,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 1) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['CR'],false,
3982,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF-- == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
3983,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z - z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
3984,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (!(position < maxPosition)) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOI'],false,
3985,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
3987,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian++ == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
3988,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length != 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['ROR'],false,
3989,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (false) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'VDL']",false,
3990,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive >= array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],true,
3991,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'CDL']",false,
3993,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j -= Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SAR'],false,
3995,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (!(c <= maxDelimCodePoint) && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOI'],false,
3996,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
        return subarray;
    }",['CR'],false,
3997,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive <= 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
3998,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse / x, 0);

  }",['AORB'],false,
3999,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (-m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIU'],false,
4000,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse % x, 0);

  }",['AORB'],false,
4002,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        ;
        return subarray;
    }",['FCDL'],false,
4003,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (++c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
4004,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x + x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
4005,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
        }
            trian = trian / 3;
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
4007,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i--;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
4008,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    ;
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['FCDL'],false,
4009,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - -1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i >= 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
4010,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = -1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
4011,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i >= delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
4013,"    public  void sort( int[] data )
    {
        if (data.length <= 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['ROR'],false,
4014,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i++ );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
4016,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition > maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['ROR'],false,
4017,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * 1.5));
        for (int i = 0; i != array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['ROR'],true,
4018,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return ~newPosition < maxPosition;
    }",['LOI'],false,
4019,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length % 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
4020,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive / startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
4022,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e++ == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
4023,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request-- > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
4026,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition--) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
4027,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; j++) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORS'],false,
4029,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse - z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
4030,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first++, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],true,
4032,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (!(data[j] < data[j - 1])) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['SEOI'],false,
4033,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize < 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
4034,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i--) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AORS'],false,
4035,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && true) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['CDL', 'ROD', 'VDL']",false,
4036,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper % 1, last );
        }
    }",['AORB'],false,
4037,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (++currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
4038,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length % 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
4039,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (false) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
4040,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (a + b < c || a + c < b || false) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'VDL']",false,
4042,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < -1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
4044,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < ++count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
4045,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) == mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
4046,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return ~INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
4047,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize < 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
4048,	public boolean removeNode(int nodeId),['ROR'],false,
4049,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z / z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
4050,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint || isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOR'],false,
4051,"public static void main(int b, int c, int d, int e, int f)",['AOIS'],true,
4052,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N--;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
4053,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive >= array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
4056,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (true) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
4057,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (false) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['CDL', 'ROD', 'VDL']",false,
4058,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive != 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
4062,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && ~c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
4065,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x-- * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
4066,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 0 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['CR'],false,
4067,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[~max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['LOI'],false,
4069,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
        if (trian != 3) {
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['SEOR'],false,
4070,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex == array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
4071,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    ;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['ADL'],false,
4073,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
4074,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (false) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
4075,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse / z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
4076,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c++) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
4077,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; ~i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['LOI'],false,
4078,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
            return ISOSCELES;
        if (trian == -1 && a + b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
4080,"	public void addNode(int id, int rate, int coverage, int xPosition,","['ROD', 'VDL']",false,
4082,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (true) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD']",false,
4083,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = -trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],true,
4084,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) - 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AORB'],false,
4085,"public static void main(int b, int c, int d, int e, int f)",['ROR'],true,
4087,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j++ );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
4088,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e == 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
4089,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u ^ 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['LOR'],false,
4090,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=abs(bonus4)+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ABSI'],true,
4092,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (-1 << k); // gcd is u*2^k
    }",['AOIU'],false,
4093,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i <= length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],false,
4094,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && false) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
4095,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
        }
            trian = trian / 2;
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
4097,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (true) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['ROD', 'SEOD', 'VDL']",false,
4098,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+++(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
4099,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
                return ISOSCELES;
            if (false && a + c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
4101,"    public  void sort( int[] data )
    {
        for (int i = 0; i < 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }","['AORB', 'VDL']",false,
4103,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m++ + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
4104,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a++) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
4105,"public static int min(int I, int J)
{
	int Min;
    Min = I;
    if(J<I) {
 	   Min=J--;}
    return Min;
}",['AOIS'],true,
4107,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (true) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
4109,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e == 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
4110,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i--]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['AOIS'],false,
4111,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound == data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
4112,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a-- == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
4113,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff == 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
4114,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( ++c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
4115,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset >= wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['ROR'],false,
4116,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m - x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
4118,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
4119,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex <= 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
4120,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 * ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AORB'],true,
4121,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t >= 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],true,
4122,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper-- - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
4123,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && false) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }","['ROD', 'VDL']",false,
4124,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j / 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORB'],false,
4125,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = m + x - 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
4126,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF <= 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
4127,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a-- + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
4128,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if ((a <= 0 || b <= 0) && c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOR'],false,
4129,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first / 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
4130,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (~c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
4133,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }","['ROD', 'SEOD', 'VDL']",false,
4135,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( ++c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
4136,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e++ == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
4137,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( ~c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
4138,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length;  ) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['AODS'],false,
4139,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian-- == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
4140,"    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length / 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
4141,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j++];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
4143,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c != maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
4145,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (false || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['ROD', 'VDL']",false,
4146,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (false) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }","['CDL', 'ROD', 'VDL']",false,
4147,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (false || a + c < b || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'VDL']",false,
4148,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c != a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
4149,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                    return ISOSCELES;
                if (trian == 0 && b + c > a) {
                }
            }
        }
        return INVALID;
    }",['CR'],false,
4150,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
                return INVALID;
            if (true || b + c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD', 'VDL']",false,
4151,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian <= 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
4152,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint++ && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
4153,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition <= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['ROR'],false,
4155,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c >= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
4156,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < -1) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
4157,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt * 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
4158,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = number--;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
4159,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i > 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
4160,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'SEOD', 'VDL']",false,
4161,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse / y, -inverse * x, 0);

  }",['AORB'],false,
4162,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x == threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['ROR'],false,
4163,"	public static void main(String args[])
{
	int m,i,k,h=0,leap=1;
	System.out.print(""\n"");
	for(m=1;m<=5;m++)
	{
		k=(int)Math.sqrt(m+1);
		for(i=2;i<=k;i++)
		{
			if(m%i==0)
			{
				leap=0;
				break;
			}
		}
		if(leap!=0)
		{
			System.out.printf(""%-4d"",m);
			h++;
			if(h%10==0)
				System.out.printf(""\n"");
		}
		leap=1;
	}
	System.out.printf(""\nThe total is %d"",h--);
}",['AOIS'],true,
4164,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian / 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
4165,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (!(c <= maxDelimCodePoint && isDelimiter( c ))) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOI'],false,
4166,	public boolean removeNode(int nodeId),['AODU'],false,
4167,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[~j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['LOI'],false,
4168,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) < 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
4169,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && --a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
4170,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive % startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
4171,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (--c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
4172,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first++ + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
4174,"    public static Map toMap(Object[] array) {
        if (array == null) {
            return null;
        }
        final Map map = new HashMap((int) (array.length * -1.5));
        for (int i = 0; i < array.length; i++) {
            Object object = array[i];
            if (object instanceof Map.Entry) {
                Map.Entry entry = (Map.Entry) object;
                map.put(entry.getKey(), entry.getValue());
            } else if (object instanceof Object[]) {
                Object[] entry = (Object[]) object;
                if (entry.length < 2) {
                    throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', has a length less than 2"");
                }
                map.put(entry[0], entry[1]);
            } else {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                        + object
                        + ""', is neither of type Map.Entry nor an Array"");
            }
        }
        return map;
    }",['AOIU'],false,
4175,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y == -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['ROR'],false,
4176,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize < 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],true,
4177,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
        if (trian == 1 && a * b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
4178,"    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex == array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
4180,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }","['SEOD', 'VDL']",false,
4181,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = -last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIU'],false,
4182,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c-- >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
4183,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
        }
            trian = trian + 0;
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['CR'],false,
4186,"    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive / startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_FLOAT_ARRAY;
        }

        float[] subarray = new float[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
4187,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( --We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
4188,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (true && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
4189,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b == 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
4191,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || true) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD']",false,
4192,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (a <= 0 || true || c <= 0) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
4193,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N++;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
4194,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j >= i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROR'],true,
4195,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && false) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['CDL', 'ROD', 'VDL']",false,
4196,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x / x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
4197,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < --c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
4199,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[--j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
4200,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while (k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }","['CDL', 'ROD', 'SEOD', 'VDL']",true,
4201,"    public  void sort( int[] data )
    {
        for (int i = 0; i <= data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROR'],true,
4202,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 + Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
4203,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp++;
                }
            }
        }
    }",['AOIS'],true,
4205,"    public  void sort( int[] data )
    {
        if (!(data.length < 2)) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['SEOI'],false,
4206,"    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (false) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_LONG_ARRAY;
        }

        long[] subarray = new long[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }","['CDL', 'ROD', 'VDL']",false,
4208,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition-- );
        return newPosition < maxPosition;
    }",['AOIS'],false,
4209,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                    return ISOSCELES;
                if (b + c > a) {
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",true,
4211,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex != 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
4212,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive / startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
4213,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind >= array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
4214,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a - b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
4218,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse - x, 0);

  }",['AORB'],false,
4219,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && ~a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
4220,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = -1;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AOIU'],false,
4225,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i];
        data[i] = data[--j];
        data[j] = tmp;
    }",['AOIS'],false,
4227,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y - y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
4229,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c++ >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
4231,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
        return subarray;
    }",['CR'],false,
4232,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = -1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AOIU'],false,
4233,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (--trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
4234,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
        if (a <= b) {
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['ROR'],false,
4235,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10--+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['AOIS'],true,
4236,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c >= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
4237,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (true) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }","['ROD', 'VDL']",false,
4238,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m++;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],true,
4239,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (true) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['VDL'],false,
4242,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, -upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIU'],false,
4243,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
4244,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ROR'],true,
4245,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
            trian = trian + 1;
        if (a <= b) {
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
4246,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && true) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD']",false,
4247,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
            return ISOSCELES;
        if (trian == 1 && a - b > c) {
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
4248,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt == offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['ROR'],false,
4250,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) != 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
4251,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e >= 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
4252,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }","['ROD', 'SEOD', 'VDL']",false,
4253,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || ~a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['LOI'],false,
4254,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c == maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
4255,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
        if (trian == -1) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['CR'],false,
4256,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'VDL']",false,
4258,"    private  void setMaxDelimCodePoint()
    {
        if (!(delimiters == null)) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['SEOI'],false,
4259,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 1; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['CR'],false,
4260,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; ++i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
4261,"	public void addNode(int id, int rate, int coverage, int xPosition,",['AORB'],false,
4264,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / -2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIU'],false,
4265,"    public  void swap( int[] data, int i, int j )
    {
        int tmp = data[i++];
        data[i] = data[j];
        data[j] = tmp;
    }",['AOIS'],false,
4266,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[++j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
4267,"    public  void sort( int[] data )
    {
        if (true) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }","['CDL', 'ROD', 'VDL']",false,
4268,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (true) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'SEOD', 'VDL']",false,
4269,"    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive != 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_CHAR_ARRAY;
        }

        char[] subarray = new char[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
4270,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; --j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AOIS'],false,
4272,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c-- > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['AOIS'],false,
4274,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }","['ROD', 'SEOD', 'VDL']",false,
4275,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (!(trian == 3 && b + c > a)) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
4276,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i;  ) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AODS'],false,
4277,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
            if (a + b < c || a + c < b || b % c < a) {
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
4280,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (false) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }","['ROD', 'VDL']",false,
4281,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (!(a + b < c) || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
4282,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition--) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
4284,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (!(c <= maxDelimCodePoint) && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['SEOI'],false,
4285,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length * 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
4286,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position-- );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
4287,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b * c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
4288,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 0) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],true,
4289,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound++ > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
4290,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (true) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['VDL'],false,
4291,"	public void addNode(int id, int rate, int coverage, int xPosition,",['ROR'],false,
4292,"    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive / startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BOOLEAN_ARRAY;
        }

        boolean[] subarray = new boolean[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
4296,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
                return ISOSCELES;
            if (trian == 2 && a * c > b) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
4297,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i <= delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['ROR'],false,
4300,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b >= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
4301,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c++ || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
4302,"    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        if (objectToFind == null) {
            for (int i = startIndex; i > 0; i--) {
                if (array[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = startIndex; i >= 0; i--) {
                if (objectToFind.equals(array[i])) {
                    return i;
                }
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
4303,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 1) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['CR'],false,
4304,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position = Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['VDL'],false,
4305,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff != 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['ROR'],false,
4306,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound > data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['ROR'],false,
4307,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i == data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length - 2 );
    }",['ROR'],false,
4309,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos );
            count++;
        }
        return count--;
    }",['AOIS'],true,
4310,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b++ > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
4312,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i--) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORS'],false,
4313,"    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (false) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
4314,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z % z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
4315,"    public  java.lang.String nextToken()
    {
        currentPosition = newPosition > 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
        delimsChanged = false;
        newPosition = -1;
        if (currentPosition >= maxPosition) {
            throw new java.util.NoSuchElementException();
        }
        int start = currentPosition;
        currentPosition = scanToken( currentPosition );
        return str.substring( start, currentPosition );
    }",['ROR'],false,
4318,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 0) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 + Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['AORB'],false,
4320,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k <= 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['ROR'],false,
4321,"    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive >= array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_SHORT_ARRAY;
        }

        short[] subarray = new short[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
4323,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a <= c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
4324,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( currpos-- );
            count++;
        }
        return count;
    }",['AOIS'],true,
4325,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength % 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],true,
4326,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && false) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD']",false,
4327,"    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive + startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_DOUBLE_ARRAY;
        }

        double[] subarray = new double[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
4328,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( ~position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
4330,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength / 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],true,
4331,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j * 1] = temp;
                }
            }
        }
    }",['AORB'],true,
4332,"    private  void setMaxDelimCodePoint()
    {
        if (true) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }","['ROD', 'VDL']",false,
4333,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive + startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
4334,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = --r;
        return r;
    }",['AOIS'],false,
4338,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[~first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['LOI'],false,
4339,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position /= Character.charCount( c );
                }
            }
        }
        return position;
    }",['SAR'],false,
4340,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[++upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
4341,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c-- < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],true,
4342,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i == 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
4343,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian > 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
4345,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i != delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['ROR'],true,
4346,"    public  boolean hasMoreTokens()
    {
        newPosition = skipDelimiters( currentPosition );
        return newPosition-- < maxPosition;
    }",['AOIS'],false,
4348,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] <= data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['ROR'],true,
4351,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return -ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIU'],false,
4352,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first-- < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
4353,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c--) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
4356,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(false ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['ROD', 'VDL']",false,
4357,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint++ && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
4358,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i-- < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['AOIS'],false,
4359,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a < 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
4360,"    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (true) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'VDL']",false,
4361,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b <= c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
4363,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AODS'],false,
4365,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (!(a == c)) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOI'],false,
4368,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = -1;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],false,
4369,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * --x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
4370,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
4371,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
            return EQUILATERAL;
        if (trian != 3) {
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROR'],false,
4374,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request-- == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
4375,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / -2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],false,
4376,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex == array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
4379,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (false && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
4380,"    public  boolean hasMoreElements()
    {
        return false;
    }",['VDL'],false,
4381,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i > 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
4383,"    public static void main(int number) {
        int[] a = new int[] { -14, 6, 28, 0 };
        int mytemp1, mytemp2, end, i, j;
        System.out.println(""original array is:\n"");
        for (i = 0; i < 3; i++) {
            System.out.printf(""%5d"", a[i]);
        }
        System.out.printf(""\n"");
        System.out.printf(""insert a new number:"");
        end = a[2];
        if (number >= end) {
            a[3] = number;
        } else {
            for (i = 0; i < 3; i++) {
                if (a[i] > number) {
                    mytemp1 = a[i];
                    a[i] = number;
                    for (j = i + 1; j < 4; j++) {
                        mytemp2 = a[j];
                        a[j] = mytemp1;
                        mytemp1 = mytemp2;
                    }
                    break;
                }
            }
        }
        for (i = 0; i < 4; i++) {
            System.out.printf(""%6d"", a[i]--);
        }
        System.out.printf(""\n"");
    }",['AOIS'],true,
4384,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = true;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['SEOR'],false,
4385,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
4386,"    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
        if (array == null) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex > array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['ROR'],false,
4387,"    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
        if (true) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['VDL'],false,
4388,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length * 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j - 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORB'],true,
4389,"    public  void sort( int[] data )
    {
        if (data.length < 2) {
            return;
        }
        int max = 0;
        for (int i = 1; i < data.length; i++) {
            if (data[max] < data[i]) {
                max = i;
            }
        }
        swap( data, data.length - 1, max );
        quicksort( data, 0, data.length );
    }","['AORB', 'CDL']",false,
4390,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b % c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
4391,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind % tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
4393,"public static void main(int b, int c, int d, int e, int f)",['AOIS'],true,
4394,"	public void addNode(int id, int rate, int coverage, int xPosition,",['CR'],true,
4396,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength - offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt / 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
4397,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF-- > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
4399,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( --i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
4401,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (--diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],true,
4403,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
                return ISOSCELES;
            if (trian == 2 && false) {
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'VDL']",false,
4404,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (m + x) / 2;
                }
            }
            diff = x * x % N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AORB'],false,
4405,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c != maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['ROR'],false,
4406,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (++m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
4408,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if ((a + b < c || a + c < b) && b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['SEOR'],false,
4409,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
            trian = trian * 3;
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }

}",['AORB'],false,
4410,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < -1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
4412,"    public  int countTokens()
    {
        int count = 0;
        int currpos = currentPosition;
        while (currpos < maxPosition) {
            currpos = skipDelimiters( currpos );
            if (currpos >= maxPosition) {
                break;
            }
            currpos = scanToken( --currpos );
            count++;
        }
        return count;
    }",['AOIS'],false,
4413,"    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive * startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_INT_ARRAY;
        }

        int[] subarray = new int[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
4414,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper / 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }",['AORB'],false,
4415,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (~c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['LOI'],false,
4417,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = ++m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
4419,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (true) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['ROD'],false,
4421,"  public Vector3D orthogonal() {

    double threshold = 0.6 * getNorm();
    if (threshold == 1) {
      throw new ArithmeticException(""null norm"");
    }

    if ((x >= -threshold) && (x <= threshold)) {
      double inverse  = 1 / Math.sqrt(y * y + z * z);
      return new Vector3D(0, inverse * z, -inverse * y);
    } else if ((y >= -threshold) && (y <= threshold)) {
      double inverse  = 1 / Math.sqrt(x * x + z * z);
      return new Vector3D(-inverse * z, 0, inverse * x);
    }
    double inverse  = 1 / Math.sqrt(x * x + y * y);
    return new Vector3D(inverse * y, -inverse * x, 0);

  }",['CR'],false,
4424,"    public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
    {
        int delimLen = delimiters == null ? -1 : delimiters.length;
        if (str == null || str.length() == 0 || delimLen == 0) {
            return str;
        }
        int strLen = str.length();
        java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
        boolean capitalizeNext = true;
        for (int i = 0; i < strLen; i++) {
            char ch = str.charAt(i);
            if (isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = false;
            } else {
                if (capitalizeNext) {
                    buffer.append(Character.toTitleCase( ch ));
                    capitalizeNext = false;
                } else {
                    buffer.append(ch);
                }
            }
        }
        return buffer.toString();
    }",['SEOR'],false,
4425,"    private  int skipDelimiters( int startPos )
    {
        if (delimiters == null) {
            throw new java.lang.NullPointerException();
        }
        int position = startPos;
        while (!retDelims && position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c > maxDelimCodePoint && delimiters.indexOf( c ) < 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c > maxDelimCodePoint || !isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        return position;
    }",['SEOR'],false,
4427,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position-- );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
4428,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                    return ISOSCELES;
                if (false && b + c > a) {
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
4431,"    private  boolean isDelimiter( int codePoint )
    {
        for (int i = 0; i < delimiterCodePoints.length; i++) {
            if (delimiterCodePoints[++i] == codePoint) {
                return true;
            }
        }
        return false;
    }",['AOIS'],false,
4432,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < ~c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['LOI'],false,
4433,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + --b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
4434,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last) {
            quicksort( data, upper + 1, last );
        }
    }","['AORB', 'VDL']",false,
4436,"public class Profit {

double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(abs(i)-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}
	double abs(double a) {
		if (a < 0) return -a;
		return a;
	}
}
",['ABSI'],true,
4437,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['AORB', 'ROD', 'SEOD']",false,
4439,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (false) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }","['ROD', 'SEOD', 'VDL']",false,
4440,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length / 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AORB'],false,
4442,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= ~maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['LOI'],false,
4444,"    public static int gcd(int u, int v) {
        if (u * v == 0) {
            return (Math.abs(u) + Math.abs(v));
        }
        // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < -31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw new ArithmeticException(""overflow: gcd is 2^31"");
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }",['AOIU'],false,
4446,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( ++c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
4449,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (s == null) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i <= length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }",['ROR'],false,
4450,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e++ > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
4451,"    private  void setMaxDelimCodePoint()
    {
        if (delimiters == null) {
            maxDelimCodePoint = 0;
            return;
        }
        int m = 0;
        int c;
        int count = 0;
        for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
            c = delimiters.charAt( i );
            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
                c = delimiters.codePointAt( i );
                hasSurrogates = true;
            }
            if (m < c) {
                m = c;
            }
            count++;
        }
        maxDelimCodePoint = m;
        if (hasSurrogates) {
            delimiterCodePoints = new int[++count];
            for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
                c = delimiters.codePointAt( j );
                delimiterCodePoints[i] = c;
            }
        }
    }",['AOIS'],false,
4453,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
            trian = trian + 1;
        if (false) {
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['ROD', 'VDL']",false,
4455,"    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive < 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive % startIndexInclusive;
        if (newSize <= 0) {
            return EMPTY_BYTE_ARRAY;
        }

        byte[] subarray = new byte[newSize];
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['AORB'],false,
4457,"    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
        if (ArrayUtils.isEmpty(array)) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < -1) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        for (int i = startIndex; i >= 0; i--) {
            if (valueToFind == array[i]) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['AOIU'],false,
4458,"    private  void quicksort( int[] data, int first, int last )
    {
        int lower = first + 1;
        int upper = last;
        swap( data, first, (first + last) / 2 );
        int bound = data[first];
        while (lower <= upper) {
            while (bound > data[lower]) {
                lower++;
            }
            while (bound < data[upper]) {
                upper--;
            }
            if (lower < upper) {
                swap( data, lower++, upper-- );
            } else {
                lower++;
            }
        }
        swap( data, upper, first );
        if (first < upper - 1) {
            quicksort( data, first, upper - 1 );
        }
        if (upper + 1 < last++) {
            quicksort( data, upper + 1, last );
        }
    }",['AOIS'],false,
4459,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + ++b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
4462,"    private String decodeName(String name) {
        final WeakReference ref = (WeakReference)unescapeCache.get(name);
        String s = (String)(ref == null ? null : ref.get());

        if (false) {
            final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
            final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
            final int length = name.length();

            // First, fast (common) case: nothing to decode
            int i = 0;

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                // We'll do a quick check for potential match
                if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                    // and if it might be a match, just quit, will check later on
                    break;
                }
            }

            if (i == length) {
                return name;
            }

            // Otherwise full processing
            final StringBuffer result = new StringBuffer(length + 8);

            // We know first N chars are safe
            if (i > 0) {
                result.append(name.substring(0, i));
            }

            for (; i < length; i++ ) {
                char c = name.charAt(i);
                if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                    i += dollarReplacement.length() - 1;
                    result.append('$');
                } else if (c == escapeReplacementFirstChar
                    && name.startsWith(escapeCharReplacement, i)) {
                    i += escapeCharReplacement.length() - 1;
                    result.append('_');
                } else {
                    result.append(c);
                }
            }

            s = result.toString();
            unescapeCache.put(name, new WeakReference(s));
        }
        return s;
    }","['ROD', 'VDL']",false,
4463,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2++ - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
4464,"    public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
    {
        if (str == null) {
            return null;
        }
        if (newLineStr == null) {
            newLineStr = SystemUtils.LINE_SEPARATOR;
        }
        if (wrapLength < 1) {
            wrapLength = 1;
        }
        int inputLineLength = str.length();
        int offset = 0;
        java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
        while (inputLineLength + offset > wrapLength) {
            if (str.charAt(offset) == ' ') {
                offset++;
                continue;
            }
            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
            if (spaceToWrapAt >= offset) {
                wrappedLine.append(str.substring(offset, spaceToWrapAt));
                wrappedLine.append(newLineStr);
                offset = spaceToWrapAt + 1;
            } else {
                if (wrapLongWords) {
                    wrappedLine.append(str.substring(offset, wrapLength + offset));
                    wrappedLine.append(newLineStr);
                    offset += wrapLength;
                } else {
                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                    if (spaceToWrapAt >= 0) {
                        wrappedLine.append(str.substring(offset, spaceToWrapAt));
                        wrappedLine.append(newLineStr);
                        offset = spaceToWrapAt + 1;
                    } else {
                        wrappedLine.append(str.substring(offset));
                        offset = inputLineLength;
                    }
                }
            }
        }
        wrappedLine.append(str.substring(offset));
        return wrappedLine.toString();
    }",['AORB'],false,
4465,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == ++c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AOIS'],false,
4466,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF > 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['ROR'],true,
4468,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c++ <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
4470,"    private  int scanToken( int startPos )
    {
        int position = startPos;
        while (position < maxPosition) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    break;
                }
                position++;
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    break;
                }
                position += Character.charCount( c );
            }
        }
        if (retDelims && startPos == position) {
            if (!hasSurrogates) {
                char c = str.charAt( position );
                if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                    position++;
                }
            } else {
                int c = str.codePointAt( position );
                if (c <= maxDelimCodePoint && isDelimiter( c )) {
                    position += Character.charCount( --c );
                }
            }
        }
        return position;
    }",['AOIS'],false,
4471,"    public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
        if (array == null) {
            return null;
        }
        if (startIndexInclusive != 0) {
            startIndexInclusive = 0;
        }
        if (endIndexExclusive > array.length) {
            endIndexExclusive = array.length;
        }
        int newSize = endIndexExclusive - startIndexInclusive;
        Class type = array.getClass().getComponentType();
        if (newSize <= 0) {
            return (Object[]) Array.newInstance(type, 0);
        }
        Object[] subarray = (Object[]) Array.newInstance(type, newSize);
        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
        return subarray;
    }",['ROR'],false,
4474,"    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
        if (false) {
            return INDEX_NOT_FOUND;
        }
        if (startIndex < 0) {
            return INDEX_NOT_FOUND;
        } else if (startIndex >= array.length) {
            startIndex = array.length - 1;
        }
        double min = valueToFind - tolerance;
        double max = valueToFind + tolerance;
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] >= min && array[i] <= max) {
                return i;
            }
        }
        return INDEX_NOT_FOUND;
    }",['VDL'],false,
4476,"    public static  int classify( int a, int b, int c )
    {
        int trian;
            return INVALID;
        if (a <= 0 || b <= 0 || true) {
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
4477,"    public  double sqrt( double N )
    {
        double x = N;
        double M = N;
        double m = 1;
        double r = x;
        double diff = x * x - N;
        while (Math.abs(diff) > mEpsilon) {
            if (diff < 0) {
                m = x;
                x = (M + x) / 2;
            } else {
                if (diff > 0) {
                    M = x;
                    x = (--m + x) / 2;
                }
            }
            diff = x * x - N;
        }
        r = x;
        mResult = r;
        return r;
    }",['AOIS'],false,
4478,"    public  void sort( int[] data )
    {
        for (int i = 0; i < data.length - 1; i++) {
            for (int j = data.length - 1; j > i; --j) {
                if (data[j] < data[j % 1]) {
                    int temp = data[j];
                    data[j] = data[j - 1];
                    data[j - 1] = temp;
                }
            }
        }
    }",['AORB'],false,
4479,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (trian > 3) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b % c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }",['AORB'],false,
4480,"    public static  int classify( int a, int b, int c )
    {
        int trian;
        if (a <= 0 || b <= 0 || c <= 0) {
            return INVALID;
        }
        trian = 0;
        if (a == b) {
            trian = trian + 1;
        }
        if (a == c) {
            trian = trian + 2;
        }
        if (b == c) {
            trian = trian + 3;
        }
        if (trian == 0) {
            if (a + b < c || a + c < b || b + c < a) {
                return INVALID;
            } else {
                return SCALENE;
            }
        }
        if (false) {
            return EQUILATERAL;
        }
        if (trian == 1 && a + b > c) {
            return ISOSCELES;
        } else {
            if (trian == 2 && a + c > b) {
                return ISOSCELES;
            } else {
                if (trian == 3 && b + c > a) {
                    return ISOSCELES;
                }
            }
        }
        return INVALID;
    }","['CDL', 'ROD', 'VDL']",false,
4482,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * ++We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}",['AOIS'],true,
4483,"    public  java.lang.String nextToken( java.lang.String delim )
    {
        delimiters = delim;
        delimsChanged = true;
        setMaxDelimCodePoint();
        return """";
    }",['VDL'],false,
